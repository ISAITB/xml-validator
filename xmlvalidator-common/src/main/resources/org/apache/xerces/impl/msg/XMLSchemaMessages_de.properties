#
# Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

# This file contains error and warning messages related to XML Schema
# The messages are arranged in key and value tuples in a ListResourceBundle.

        BadMessageKey = Die zum Meldungsschl\u00FCssel geh\u00F6rige Fehlermeldung kann nicht gefunden werden.
        FormatFailed = Beim Formatieren der folgenden Meldung ist ein interner Fehler aufgetreten:

# For internal use

        Internal-Error = Interner Fehler: {0}.
        dt-whitespace = Leerstellen-Facet-Wert ist nicht f\u00FCr Vereinigungsmenge simpleType "{0}" verf\u00FCgbar
        GrammarConflict = Eine vom Grammatikpool des Benutzers zur\u00FCckgegebene Grammatik steht im Konflikt mit einer anderen Grammatik.

# Identity constraints

        AbsentKeyValue = cvc-identity-constraint.4.2.1.a: Element "{0}" hat keinen Wert f\u00FCr den Schl\u00FCssel "{1}".
        DuplicateField = Doppelte \u00DCbereinstimmung in Geltungsbereich f\u00FCr Feld "{0}".
        DuplicateKey = cvc-identity-constraint.4.2.2: Doppelter Schl\u00FCsselwert [{0}] f\u00FCr Identity Constraint "{2}" des Elements "{1}"deklariert.
        DuplicateUnique = cvc-identity-constraint.4.1: Doppelter eindeutiger Wert [{0}] f\u00FCr Identity Constraint "{2}"des Elements "{1}" deklariert.
        FieldMultipleMatch = cvc-identity-constraint.3: Feld "{0}" von Identity Constraint "{1}" entspricht mehreren Werten im Geltungsbereich seines Selektors. Felder m\u00FCssen eindeutigen Werten entsprechen.
        FixedDiffersFromActual = Content dieses Elements entspricht nicht dem Wert des "fixed"-Attributs in der Elementdeklaration im Schema.
        KeyMatchesNillable = cvc-identity-constraint.4.2.3: Element "{0}" hat den Schl\u00FCssel "{1}", der einem Element entspricht, bei dem "nillable" auf "true" gesetzt wurde.
        KeyNotEnoughValues = cvc-identity-constraint.4.2.1.b: Nicht gen\u00FCgend Werte angegeben f\u00FCr <key name="{1}"> Identity Constraint f\u00FCr Element "{0}".
        KeyNotFound = cvc-identity-constraint.4.3: Schl\u00FCssel "{0}" mit Wert "{1}" nicht gefunden f\u00FCr Identity Constraint des Elements "{2}".
        KeyRefOutOfScope = Identity Constraint-Fehler: Identity Constraint "{0}" hat eine keyref, die zu einem Key- oder Unique-Constraint au\u00DFerhalb des Geltungsbereichs verweist.
        KeyRefReferNotFound = Schl\u00FCsselreferenzdeklaration "{0}" verweist auf einen unbekannten Schl\u00FCssel mit dem Namen "{1}".
        UnknownField = Interner Identity Constraint-Fehler. Unbekanntes Feld "{0}" f\u00FCr Identity Constraint "{2}", das f\u00FCr Element "{1}" angegeben wurde.

# Ideally, we should only use the following error keys, not the ones under
# "Identity constraints". And we should cover all of the following errors.

#validation (3.X.4)

        cvc-attribute.3 = cvc-attribute.3: Wert "{2}" des Attributs "{1}" bei Element "{0}" hat keinen g\u00FCltigen Typ "{3}".
        cvc-attribute.4 = cvc-attribute.4: Wert "{2}" des Attributs "{1}" bei Element "{0}" hat keinen g\u00FCltigen festen "{"value constraint"}". Attribute muss den Wert "{3}" haben.
        cvc-complex-type.2.1 = cvc-complex-type.2.1: Element "{0}" darf kein Zeichen- oder Elementinformationselement [untergeordnete Elemente] haben, da der Contenttyp des Typs leer ist.
        cvc-complex-type.2.2 = cvc-complex-type.2.2: Element "{0}" darf kein Element [untergeordnete Elemente] haben, und der Wert muss g\u00FCltig sein.
        cvc-complex-type.2.3 = cvc-complex-type.2.3: Element "{0}" darf keine Zeichen [untergeordnete Elemente] haben, da der Contenttyp des Typs "element-only" ist.
        cvc-complex-type.2.4.a = cvc-complex-type.2.4.a: Ung\u00FCltiger Content wurde beginnend mit Element "{0}" gefunden. "{1}" wird erwartet.
        cvc-complex-type.2.4.b = cvc-complex-type.2.4.b: Content des Elements "{0}" ist nicht vollst\u00E4ndig. "{1}" wird erwartet.
        cvc-complex-type.2.4.c = cvc-complex-type.2.4.c: \u00DCbereinstimmungsplatzhalter ist streng, aber es kann keine Deklaration f\u00FCr Element "{0}" gefunden werden.
        cvc-complex-type.2.4.d = cvc-complex-type.2.4.d: Ung\u00FCltiger Content wurde beginnend mit Element "{0}" gefunden. An dieser Stelle wird kein untergeordnetes Element erwartet.
        cvc-complex-type.2.4.d.1 = cvc-complex-type.2.4.d: Ung\u00FCltiger Content wurde beginnend mit Element "{0}" gefunden. An dieser Stelle wird kein untergeordnetes Element "{1}" erwartet.
        cvc-complex-type.2.4.e = cvc-complex-type.2.4.e: "{0}" darf maximal "{2}"-mal in der aktuellen Abfolge auftreten. Dieser Grenzwert wurde \u00FCberschritten. An dieser Stelle wird eines von "{1}" erwartet.
        cvc-complex-type.2.4.f = cvc-complex-type.2.4.e: "{0}" darf maximal "{1}"-mal in der aktuellen Abfolge auftreten. Dieser Grenzwert wurde \u00FCberschritten. An dieser Stelle wird kein untergeordnetes Element erwartet.
        cvc-complex-type.2.4.g = cvc-complex-type.2.4.g: Ung\u00FCltigen Inhalt gefunden, der mit Element "{0}" beginnt. "{1}" soll erwartungsgem\u00E4\u00DF mindestens "{2}"-mal in der aktuellen Abfolge auftreten. Eine weitere Instanz ist erforderlich, um diesen Constraint zu erf\u00FCllen.
        cvc-complex-type.2.4.h = cvc-complex-type.2.4.h: Ung\u00FCltigen Inhalt gefunden, der mit Element "{0}" beginnt. "{1}" soll erwartungsgem\u00E4\u00DF mindestens "{2}"-mal in der aktuellen Abfolge auftreten. "{3}" weitere Instanzen sind erforderlich, um diesen Constraint zu erf\u00FCllen.
        cvc-complex-type.2.4.i = cvc-complex-type.2.4.i: Der Inhalt von Element "{0}" ist nicht vollst\u00E4ndig. "{1}" soll erwartungsgem\u00E4\u00DF mindestens "{2}"-mal auftreten. Eine weitere Instanz ist erforderlich, um diesen Constraint zu erf\u00FCllen.
        cvc-complex-type.2.4.j = cvc-complex-type.2.4.j: Der Inhalt von Element "{0}" ist nicht vollst\u00E4ndig. "{1}" soll erwartungsgem\u00E4\u00DF mindestens "{2}"-mal auftreten. "{3}" weitere Instanzen sind erforderlich, um diesen Constraint zu erf\u00FCllen.
        cvc-complex-type.3.1 = cvc-complex-type.3.1: Wert "{2}" des Attributs "{1}" des Elements "{0}" ist ung\u00FCltig in Bezug auf die entsprechende Attributverwendung. Attribut "{1}" hat den festen Wert "{3}".
        cvc-complex-type.3.2.1 = cvc-complex-type.3.2.1: Element "{0}" hat keinen Attributplatzhalter f\u00FCr Attribut "{1}".
        cvc-complex-type.3.2.2 = cvc-complex-type.3.2.2: Attribut "{1}" darf nicht in Element "{0}" vorkommen.
        cvc-complex-type.4 = cvc-complex-type.4: Attribut "{1}" muss in Element "{0}" vorkommen.
        cvc-complex-type.5.1 = cvc-complex-type.5.1: In Element "{0}" ist Attribut "{1}" ein Platzhalter. Es ist aber bereits ein Platzhalter "{2}" vorhanden. Nur ein Platzhalter ist zul\u00E4ssig.
        cvc-complex-type.5.2 = cvc-complex-type.5.2: In Element "{0}" ist Attribut "{1}" ein Platzhalter. Es ist aber bereits ein Attribut "{2}" vorhanden, das von einer ID unter den "{"attribute uses"}" abgeleitet wurde.
        cvc-datatype-valid.1.2.1 = cvc-datatype-valid.1.2.1: "{0}" ist kein g\u00FCltiger Wert f\u00FCr "{1}".
        cvc-datatype-valid.1.2.2 = cvc-datatype-valid.1.2.2: "{0}" ist kein g\u00FCltiger Wert des Listentyps "{1}".
        cvc-datatype-valid.1.2.3 = cvc-datatype-valid.1.2.3: "{0}" ist kein g\u00FCltiger Wert des Vereinigungsmengentyps "{1}".
        cvc-elt.1.a = cvc-elt.1.a: Deklaration des Elements "{0}" kann nicht gefunden werden.
        cvc-elt.1.b = cvc-elt.1.b: Der Name des Elements stimmt nicht mit dem Namen der Elementdeklaration \u00FCberein. Gefunden: "{0}". Erwartet: "{1}".
        cvc-elt.2 = cvc-elt.2: Wert von "{"abstract"}" in der Elementdeklaration f\u00FCr "{0}" muss "false" sein.
        cvc-elt.3.1 = cvc-elt.3.1: Attribut "{1}" darf nicht in Element "{0}" vorkommen, da die die Eigenschaft "{"nillable"}" von "{0}" "false" ist.
        cvc-elt.3.2.1 = cvc-elt.3.2.1: Element "{0}" darf keine Zeichen- oder Elementinformationen [untergeordnete Elemente] haben, da "{1}" angegeben wurde.
        cvc-elt.3.2.2 = cvc-elt.3.2.2: Es darf kein fester "{"value constraint"}" f\u00FCr Element "{0}" vorhanden sein, da "{1}" angegeben wurde.
        cvc-elt.4.1 = cvc-elt.4.1: Wert "{2}" des Attributs "{1}" von Element "{0}" ist kein g\u00FCltiger QName.
        cvc-elt.4.2 = cvc-elt.4.2: "{1}" kann nicht als Typdefinition f\u00FCr Element "{0}" aufgel\u00F6st werden.
        cvc-elt.4.3 = cvc-elt.4.3: Typ "{1}" wurde nicht auf g\u00FCltige Weise von der Typdefinition "{2}" des Elements "{0}" abgeleitet.
        cvc-elt.5.1.1 = cvc-elt.5.1.1: "{"value constraint"}" "{2}" des Elements "{0}" ist kein g\u00FCltiger Standardwert f\u00FCr Typ "{1}".
        cvc-elt.5.2.2.1 = cvc-elt.5.2.2.1: Element "{0}" darf keine Elementinformationselemente [untergeordnete Elemente] haben.
        cvc-elt.5.2.2.2.1 = cvc-elt.5.2.2.2.1: Wert "{1}" des Elements "{0}" stimmt nicht mit dem festen "{"value constraint"}"-Wert "{2}" \u00FCberein.
        cvc-elt.5.2.2.2.2 = cvc-elt.5.2.2.2.2: Wert "{1}" des Elements "{0}" stimmt nicht mit dem "{"value constraint"}"-Wert "{2}" \u00FCberein.
        cvc-enumeration-valid = cvc-enumeration-valid: Wert "{0}" ist nicht Facet-g\u00FCltig in Bezug auf Enumeration "{1}". Er muss ein Wert aus der Enumeration sein.
        cvc-fractionDigits-valid = cvc-fractionDigits-valid: Wert "{0}" enth\u00E4lt {1} Bruchziffern, die Anzahl an Bruchziffern wurde aber auf {2} beschr\u00E4nkt.
        cvc-id.1 = cvc-id.1: Kein ID/IDREF-Binding f\u00FCr IDREF "{0}" vorhanden.
        cvc-id.2 = cvc-id.2: ID-Wert "{0}" kommt mehrmals vor.
        cvc-id.3 = cvc-id.3: Ein Feld von Identity Constraint "{0}" entsprach Element "{1}". Dieses Element hat aber keinen Simple Type.
        cvc-length-valid = cvc-length-valid: Wert "{0}" mit L\u00E4nge = "{1}" ist nicht Facet-g\u00FCltig in Bezug auf die L\u00E4nge "{2}" f\u00FCr Typ "{3}".
        cvc-maxExclusive-valid = cvc-maxExclusive-valid: Wert "{0}" ist nicht Facet-g\u00FCltig in Bezug auf maxExclusive "{1}" f\u00FCr Typ "{2}".
        cvc-maxInclusive-valid = cvc-maxInclusive-valid: Wert "{0}" ist nicht Facet-g\u00FCltig in Bezug auf maxInclusive "{1}" f\u00FCr Typ "{2}".
        cvc-maxLength-valid = cvc-maxLength-valid: Wert "{0}" mit L\u00E4nge = "{1}" ist nicht Facet-g\u00FCltig in Bezug auf maxLength "{2}" f\u00FCr Typ "{3}".
        cvc-minExclusive-valid = cvc-minExclusive-valid: Wert "{0}" ist nicht Facet-g\u00FCltig in Bezug auf minExclusive "{1}" f\u00FCr Typ "{2}".
        cvc-minInclusive-valid = cvc-minInclusive-valid: Wert "{0}" ist nicht Facet-g\u00FCltig in Bezug auf minInclusive "{1}" f\u00FCr Typ "{2}".
        cvc-minLength-valid = cvc-minLength-valid: Wert "{0}" mit L\u00E4nge = "{1}" ist nicht Facet-g\u00FCltig in Bezug auf minLength "{2}" f\u00FCr Typ "{3}".
        cvc-pattern-valid = cvc-pattern-valid: Wert "{0}" ist nicht Facet-g\u00FCltig in Bezug auf Muster "{1}" f\u00FCr Typ "{2}".
        cvc-totalDigits-valid = cvc-totalDigits-valid: Wert "{0}" enth\u00E4lt {1} Gesamtziffern, die Anzahl an Gesamtziffern wurde aber auf {2} beschr\u00E4nkt.
        cvc-type.1 = cvc-type.1: Die Typdefinition "{0}" wurde nicht gefunden.
        cvc-type.2 = cvc-type.2: Typdefinition kann nicht abstrakt f\u00FCr Element {0} sein.
        cvc-type.3.1.1 = cvc-type.3.1.1: Element "{0}" ist Simple Type und kann daher keine Attribute haben, mit Ausnahme der Attribute, deren Namespace-Name mit "http://www.w3.org/2001/XMLSchema-instance" identisch ist und deren [lokaler Name] "type", "nil", "schemaLocation" oder "noNamespaceSchemaLocation" lautet. Es wurde allerdings das Attribut "{1}" gefunden.
        cvc-type.3.1.2 = cvc-type.3.1.2: Element "{0}" ist Simple Type und darf daher keine Elementinformationselemente [untergeordnete Elemente] haben.
        cvc-type.3.1.3 = cvc-type.3.1.3: Wert "{1}" des Elements "{0}" ist ung\u00FCltig.

#schema valid (3.X.3)

        schema_reference.access = schema_reference: Schemadokument "{0}" konnte nicht gelesen werden, weil der "{1}"-Zugriff wegen der von der Eigenschaft accessExternalSchema festgelegten Einschr\u00E4nkung nicht zul\u00E4ssig ist. 
        schema_reference.4 = schema_reference.4: Schemadokument "{0}" konnte nicht gelesen werden, da 1) das Dokument nicht gefunden werden konnte; 2) das Dokument nicht gelesen werden konnte; 3) das Root-Element des Dokuments nicht <xsd:schema> ist.
        src-annotation = src-annotation: <annotation>-Elemente k\u00F6nnen nur <appinfo>- und <documentation>-Elemente enthalten, aber es wurde "{0}" gefunden.
        src-attribute.1 = src-attribute.1: Die Eigenschaften "default" und "fixed" k\u00F6nnen nicht beide in der Attributdeklaration "{0}" vorhanden sein. Verwenden Sie nur eine dieser Eigenschaften.
        src-attribute.2 = src-attribute.2: : Eigenschaft "default" ist im Attribut "{0}" vorhanden. Daher muss der Wert von "use" "optional" lauten.
        src-attribute.3.1 = src-attribute.3.1: "ref" oder "name" muss in einer lokalen Attributdeklaration vorhanden sein.
        src-attribute.3.2 = src-attribute.3.2: Content muss mit (annotation?) f\u00FCr die Attributreferenz "{0}" \u00FCbereinstimmen.
        src-attribute.4 = src-attribute.4: Attribut "{0}" hat sowohl das Attribut "type" als auch ein anonymes untergeordnetes Element "simpleType". Nur eins davon ist f\u00FCr Attribute zul\u00E4ssig.
        src-attribute_group.2 = src-attribute_group.2: Schnittmenge von Platzhaltern kann nicht f\u00FCr Attributgruppe "{0}" ausgedr\u00FCckt werden.
        src-attribute_group.3 = src-attribute_group.3: Zyklische Definitionen f\u00FCr Attributgruppe "{0}" ermittelt. Das rekursive Folgen von Attributgruppenreferenzen f\u00FChrt schlie\u00DFlich zu sich selbst zur\u00FCck.
        src-ct.1 = src-ct.1: Darstellungsfehler bei Complex Type-Definition f\u00FCr Typ "{0}". Wenn <complexContent> verwendet wird, muss der Basistyp ein complexType sein. "{1}" ist ein simpleType.
        src-ct.2.1 = src-ct.2.1: Darstellungsfehler bei Complex Type-Definition f\u00FCr Typ "{0}". Wenn <simpleContent> verwendet wird, muss der Basistyp ein complexType sein, dessen Contenttyp "simple" ist, oder, wenn eine Einschr\u00E4nkung angegeben wurde, ein "complex"-Typ mit gemischtem Content und einem Partikel, das geleert werden kann, oder, wenn eine Erweiterung angegeben wurde, ein "simple"-Typ. "{1}" erf\u00FCllt keine dieser Bedingungen.
        src-ct.2.2 = src-ct.2.2: Darstellungsfehler bei Complex Type-Definition f\u00FCr Typ "{0}". Wenn ein complexType mit simpleContent einen complexType mit gemischtem Content und einem Partikel, das geleert werden kann, einschr\u00E4nkt, muss ein <simpleType> in den untergeordneten Elementen von <restriction> enthalten sein.
        src-ct.4 = src-ct.4: Darstellungsfehler bei Complex Type-Definition f\u00FCr Typ "{0}". Die Schnittmenge der Platzhalter kann nicht ausgedr\u00FCckt werden.
        src-ct.5 = src-ct.5: Darstellungsfehler bei Complex Type-Definition f\u00FCr Typ "{0}". Die Vereinigungsmenge der Platzhalter kann nicht ausgedr\u00FCckt werden.
        src-element.1 = src-element.1: Die Eigenschaften "default" und "fixed" k\u00F6nnen nicht beide in der Elementdeklaration "{0}" vorhanden sein. Verwenden Sie nur eine dieser Eigenschaften.
        src-element.2.1 = src-element.2.1: : "ref" oder "name" muss in einer lokalen Elementdeklaration vorhanden sein.
        src-element.2.2 = src-element.2.2: Da "{0}" das Attribut "ref" enth\u00E4lt, muss der Content (annotation?) entsprechen. Es wurde allerdings "{1}" gefunden.
        src-element.3 = src-element.3: Element "{0}" hat sowohl das Attribut "type" als auch ein untergeordnetes Element "anonymous type". Nur eins davon ist f\u00FCr Elemente zul\u00E4ssig.
        src-import.1.1 = src-import.1.1: Namespace-Attribut "{0}" eines <import>-Elementinformationselements darf nicht mit dem targetNamespace des Schemas identisch sein, in dem es vorhanden ist.
        src-import.1.2 = src-import.1.2: Wenn das Namespace-Attribut nicht bei einem <import>-Elementinformationselement vorhanden ist, muss das einschlie\u00DFende Schema einen targetNamespace haben.
        src-import.2 = src-import.2: Das Root-Element des Dokuments "{0}" muss den Namespace-Namen "http://www.w3.org/2001/XMLSchema" und den lokalen Namen "schema" haben.
        src-import.3.1 = src-import.3.1: Namespace-Attribut "{0}" eines <import>-Elementinformationselements muss mit dem targetNamespace-Attribut "{1}" des importierten Dokuments identisch sein.
        src-import.3.2 = src-import.3.2: Es wurde ein <import>-Elementinformationselement ohne Namespace-Attribut gefunden. Daher kann das importierte Dokument kein targetNamespace-Attribut haben. targetNamespace "{1}" wurde aber im importierten Dokument gefunden.
        src-include.1 = src-include.1: Das Root-Element des Dokuments "{0}" muss den Namespace-Namen "http://www.w3.org/2001/XMLSchema" und den lokalen Namen "schema" haben.
        src-include.2.1 = src-include.2.1: targetNamespace des referenzierten Schemas, derzeit "{1}", muss mit dem im umfassenden Schema, derzeit "{0}", identisch sein.
        src-redefine.2 = src-redefine.2: Das Root-Element des Dokuments "{0}" muss den Namespace-Namen "http://www.w3.org/2001/XMLSchema" und den lokalen Namen "schema" haben.
        src-redefine.3.1 = src-redefine.3.1: targetNamespace des referenzierten Schemas, derzeit "{1}", muss mit dem im neu definierenden Schema, derzeit "{0}", identisch sein.
        src-redefine.5.a.a = src-redefine.5.a.a: Keine untergeordneten Nicht-Annotationselemente von <simpleType> gefunden. Untergeordnete <simpleType>-Elemente von <redefine>-Elementen m\u00FCssen <restriction>-Nachkommen mit "base"-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.a.b = src-redefine.5.a.b: "{0}" ist kein g\u00FCltiges untergeordnetes Element. Untergeordnete <simpleType>-Elemente von <redefine>-Elementen m\u00FCssen <restriction>-Nachkommen mit "base"-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.a.c = src-redefine.5.a.c: "{0}" hat kein "base"-Attribut, das auf das neu definierte Element "{1}" verweist. Untergeordnete <simpleType>-Elemente von <redefine>-Elementen m\u00FCssen <restriction>-Nachkommen mit "base"-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.b.a = src-redefine.5.b.a: Keine untergeordneten Nicht-Annotationselemente von <complexType> gefunden. Untergeordnete <complexType>-Elemente von <redefine>-Elementen m\u00FCssen <extension>- oder <restriction>-Nachkommen mit "base"-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.b.b = src-redefine.5.b.b: Keine untergeordneten Nicht-Annotationselemente der zweiten Generation von <complexType> gefunden. Untergeordnete <complexType>-Elemente von <redefine>-Elementen m\u00FCssen <extension>- oder <restriction>-Nachkommen mit "base"-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.b.c = src-redefine.5.b.c: "{0}" ist kein g\u00FCltiges untergeordnetes Element der zweiten Generation. Untergeordnete <complexType>-Elemente von <redefine>-Elementen m\u00FCssen <extension>- oder <restriction>-Nachkommen mit "base"-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.b.d = src-redefine.5.b.d: "{0}" hat kein "base"-Attribut, das auf das neu definierte Element "{1}" verweist. Untergeordnete <complexType>-Elemente von <redefine>-Elementen m\u00FCssen <extension>- oder <restriction>-Nachkommen mit "base"-Attributen haben, die auf sich selbst verweisen.
        src-redefine.6.1.1 = src-redefine.6.1.1: Wenn ein untergeordnetes Gruppenelement eines <redefine>-Elements eine Gruppe enth\u00E4lt, die auf sich selbst verweist, muss genau 1 vorhanden sein. Hier sind "{0}" vorhanden.
        src-redefine.6.1.2 = src-redefine.6.1.2: Bei Gruppe "{0}", die eine Referenz zu einer Gruppe enth\u00E4lt, die neu definiert wird, muss "minOccurs" = "maxOccurs" = 1 gelten.
        src-redefine.6.2.1 = src-redefine.6.2.1: Keine Gruppe im neu definierten Schema hat einen Namen, der "{0}" entspricht.
        src-redefine.6.2.2 = src-redefine.6.2.2: Gruppe "{0}" schr\u00E4nkt die Gruppe, die neu definiert wird, nicht ordnungsgem\u00E4\u00DF ein. Verletzter Constraint: "{1}".
        src-redefine.7.1 = src-redefine.7.1: Wenn ein untergeordnetes attributeGroup-Element eines <redefine>-Elements eine attributeGroup enth\u00E4lt, die auf sich selbst verweist, muss genau 1 vorhanden sein. Hier sind {0} vorhanden.
        src-redefine.7.2.1 = src-redefine.7.2.1: Keine attributeGroup im neu definierten Schema hat einen Namen, der "{0}" entspricht.
        src-redefine.7.2.2 = src-redefine.7.2.2: attributeGroup "{0}" schr\u00E4nkt die attributeGroup, die neu definiert wird, nicht ordnungsgem\u00E4\u00DF ein. Verletzter Constraint: "{1}".
        src-resolve = src-resolve: Name "{0}" kann nicht als "{1}"-Komponente aufgel\u00F6st werden.
        src-resolve.4.1 = src-resolve.4.1: Fehler beim Aufl\u00F6sen von Komponente "{2}". Es wurde ermittelt, dass "{2}" keinen Namespace hat, aber Komponenten ohne Ziel-Namespace k\u00F6nnen nicht aus Schemadokument "{0}" referenziert werden. Wenn "{2}" einen Namespace haben soll, muss m\u00F6glicherweise ein Pr\u00E4fix angegeben werden. Wenn "{2}" keinen Namespace haben soll, muss ein "import" ohne "namespace"-Attribut zu "{0}" hinzugef\u00FCgt werden.
        src-resolve.4.2 = src-resolve.4.2: Fehler beim Aufl\u00F6sen von Komponente "{2}". Es wurde ermittelt, dass "{2}" in Namespace "{1}" vorhanden ist, aber Komponenten aus diesem Namespace k\u00F6nnen nicht aus Schemadokument "{0}" referenziert werden. Wenn dies der falsche Namespace ist, muss m\u00F6glicherweise das Pr\u00E4fix von "{2}" ge\u00E4ndert werden. Wenn dies der richtige Namespace ist, muss ein entsprechendes "import"-Tag zu "{0}" hinzugef\u00FCgt werden.
        src-simple-type.2.a = src-simple-type.2.a: Es wurde ein <restriction>-Element gefunden, das sowohl ein "base"-[Attribut] als auch ein <simpleType>-Element in seinen [untergeordneten Elementen] enth\u00E4lt. Nur eines davon ist zul\u00E4ssig.
        src-simple-type.2.b = src-simple-type.2.b: Es wurde ein <restriction>-Element gefunden, das weder ein "base"-[Attribut] noch ein <simpleType>-Element in seinen [untergeordneten Elementen] enth\u00E4lt. Eines davon ist erforderlich.
        src-simple-type.3.a = src-simple-type.3.a: Es wurde ein <list>-Element gefunden, das sowohl ein "itemType"-[Attribut] als auch ein <simpleType>-Element in seinen [untergeordneten Elementen] enth\u00E4lt. Nur eines davon ist zul\u00E4ssig.
        src-simple-type.3.b = src-simple-type.3.b: Es wurde ein <list>-Element gefunden, das weder ein "itemType"-[Attribut] noch ein <simpleType>-Element in seinen [untergeordneten Elementen] enth\u00E4lt. Eines davon ist erforderlich.
        src-single-facet-value = src-single-facet-value: Facet "{0}" ist mehrmals definiert.
        src-union-memberTypes-or-simpleTypes = src-union-memberTypes-or-simpleTypes: Ein <union>-Element muss entweder ein nicht leeres memberTypes-[Attribut] oder mindestens ein <simpleType>-Element in seinen [untergeordneten Elementen] enthalten.

#constraint valid (3.X.6)

        ag-props-correct.2 = ag-props-correct.2: Fehler bei Attributgruppe "{0}". Es wurden doppelte Attributverwendungen mit demselben Namen und Ziel-Namespace angegeben. Name der doppelten Attributverwendung lautet "{1}".
        ag-props-correct.3 = ag-props-correct.3: Fehler bei Attributgruppe "{0}". Zwei Attributdeklarationen ("{1}" und "{2}") haben Typen, die aus ID abgeleitet wurden.
        a-props-correct.2 = a-props-correct.2: Ung\u00FCltiger Werte-Constraint-Wert "{1}" in Attribut "{0}".
        a-props-correct.3 = a-props-correct.3: Bei Attribut "{0}" kann "fixed" oder "default" nicht verwendet werden, da die "{"type definition"}" des Attributs "ID" ist oder aus ID abgeleitet wurde.
        au-props-correct.2 = au-props-correct.2: In der Attributdeklaration von "{0}" wurde der feste Wert "{1}" angegeben. Wenn also die Attributverwendung, die auf "{0}" verweist, auch einen "{"value constraint"}" hat, muss sie fest sein, und der Wert muss "{1}" lauten.
        cos-all-limited.1.2 = cos-all-limited.1.2: Eine "all"-Modellgruppe muss in einem Partikel mit "{"min occurs"}" = "{"max occurs"}" = 1 vorkommen, und dieses Partikel muss zu einem Paar geh\u00F6ren, das den "{"content type"}" einer Complex Type-Definition darstellt.
        cos-all-limited.2 = cos-all-limited.2: "{"max occurs"}" eines Elements in einer "all"-Modellgruppe muss 0 oder 1 sein. Der Wert "{0}" f\u00FCr Element "{1}" ist ung\u00FCltig.
        cos-applicable-facets = cos-applicable-facets: Facet "{0}" ist nicht zul\u00E4ssig f\u00FCr Typ {1}.
        cos-ct-extends.1.1 = cos-ct-extends.1.1: Typ "{0}" wurde durch die Erweiterung von Typ "{1}" abgeleitet. Das Attribut "final" von "{1}" l\u00E4sst die Ableitung durch Erweiterung aber nicht zu.
        cos-ct-extends.1.4.3.2.2.1.a = cos-ct-extends.1.4.3.2.2.1.a: Der Contenttyp eines abgeleiteten Typs und der seiner Basis m\u00FCssen beide "mixed" oder "element-only" sein. Typ "{0}" ist "element only", aber sein Basistyp nicht.
        cos-ct-extends.1.4.3.2.2.1.b = cos-ct-extends.1.4.3.2.2.1.b: Der Contenttyp eines abgeleiteten Typs und der seiner Basis m\u00FCssen beide "mixed" oder "element-only" sein. Typ "{0}" ist "mixed", aber sein Basistyp nicht.
        cos-element-consistent = cos-element-consistent: Fehler bei Typ "{0}". Mehrere Elemente mit Namen "{1}" und unterschiedlichen Typen kommen in der Modellgruppe vor.
        cos-list-of-atomic = cos-list-of-atomic: In der Definition von Listentyp "{0}" ist Typ "{1}" ein ung\u00FCltiger Listenelementtyp, da er nicht atomar ist ("{1}" ist entweder ein Listentyp oder ein Vereinigungsmengentyp, der eine Liste enth\u00E4lt).
        cos-nonambig = cos-nonambig: {0} und {1} (oder Elemente aus ihrer Substitutionsgruppe) verletzen "Unique Particle Attribution". Bei der Validierung f\u00FCr dieses Schema w\u00FCrde eine Mehrdeutigkeit f\u00FCr diese beiden Partikel erstellt.
        cos-particle-restrict.a = cos-particle-restrict.a: Abgeleitetes Partikel ist leer, und die Basis kann nicht geleert werden.
        cos-particle-restrict.b = cos-particle-restrict.b: Basispartikel ist leer, aber das abgeleitete Partikel ist nicht leer.
        cos-particle-restrict.2 = cos-particle-restrict.2: Unzul\u00E4ssige Partikeleinschr\u00E4nkung: "{0}".
        cos-st-restricts.1.1 = cos-st-restricts.1.1: Typ "{1}" ist atomar. Daher muss die zugeh\u00F6rige "{"base type definition"}" "{0}" eine atomare Simple Type-Definition oder ein integrierter primitiver Datentyp sein.
        cos-st-restricts.2.1 = cos-st-restricts.2.1: In der Definition von Listentyp "{0}" ist Typ "{1}" ein ung\u00FCltiger Elementtyp, da er entweder ein Listentyp oder ein Vereinigungsmengentyp ist, der eine Liste enth\u00E4lt.
        cos-st-restricts.2.3.1.1 = cos-st-restricts.2.3.1.1: Komponente "{"final"}" der "{"item type definition"}" "{0}" enth\u00E4lt "list". Dies bedeutet, dass "{0}" nicht als Elementtyp f\u00FCr Listentyp "{1}" verwendet werden kann.
        cos-st-restricts.3.3.1.1 = cos-st-restricts.3.3.1.1: Komponente "{"final"}" der "{"member type definitions"}" "{0}" enth\u00E4lt "union". Dies bedeutet, dass "{0}" nicht als Mitgliedstyp f\u00FCr Vereinigungsmengentyp "{1}" verwendet werden kann.
        cos-valid-default.2.1 = cos-valid-default.2.1: Element "{0}" hat einen Werte-Constraint und muss ein Misch- oder ein einfaches Contentmodell haben.
        cos-valid-default.2.2.2 = cos-valid-default.2.2.2: Da Element "{0}" einen "{"value constraint"}" hat und seine Typdefinition einen gemischten "{"content type"}" hat, muss das Partikel des "{"content type"}" geleert werden k\u00F6nnen.
        c-props-correct.2 = c-props-correct.2: Kardinalit\u00E4t von Feldern f\u00FCr keyref "{0}" und Schl\u00FCssel "{1}" muss sich gegenseitig entsprechen.
        ct-props-correct.3 = ct-props-correct.3: Zyklische Definitionen f\u00FCr Complex Type "{0}" ermittelt. Dies bedeutet, dass "{0}" in der eigenen Typhierarchie enthalten ist. Dies ist ein Fehler.
        ct-props-correct.4 = ct-props-correct.4: Fehler bei Typ "{0}". Es wurden doppelte Attributverwendungen mit demselben Namen und Ziel-Namespace angegeben. Name der doppelten Attributverwendung lautet "{1}".
        ct-props-correct.5 = ct-props-correct.5: Fehler bei Typ "{0}". Zwei Attributdeklarationen ("{1}" und "{2}") haben Typen, die aus ID abgeleitet wurden.
        derivation-ok-restriction.1 = derivation-ok-restriction.1: Typ "{0}" wurde durch die Einschr\u00E4nkung von Typ "{1}" abgeleitet. "{1}" hat aber eine "{"final"}"-Eigenschaft, die die Ableitung durch Einschr\u00E4nkung nicht zul\u00E4sst.
        derivation-ok-restriction.2.1.1 = derivation-ok-restriction.2.1.1: Fehler bei Typ "{0}". Attributverwendung "{1}" in diesem Typ hat den "use"-Wert "{2}", der nicht mit dem Wert von "required" in einer \u00FCbereinstimmenden Attributverwendung im Basistyp konsistent ist.
        derivation-ok-restriction.2.1.2 = derivation-ok-restriction.2.1.2: Fehler bei Typ "{0}". Attributverwendung "{1}" in diesem Typ hat den Typ "{2}", der nicht auf g\u00FCltige Weise von "{3}" abgeleitet wurde, dem Typ der \u00FCbereinstimmenden Attributverwendung im Basistyp.
        derivation-ok-restriction.2.1.3.a = derivation-ok-restriction.2.1.3.a: Fehler bei Typ "{0}". Attributverwendung "{1}" in diesem Typ hat einen effektiven Werte-Constraint, der nicht fest ist, und der effektive Werte-Constraint der \u00FCbereinstimmenden Attributverwendung im Basistyp ist fest.
        derivation-ok-restriction.2.1.3.b = derivation-ok-restriction.2.1.3.b: Fehler bei Typ "{0}". Attributverwendung "{1}" in diesem Typ hat einen effektiven festen Werte-Constraint mit dem Wert "{2}". Dies ist nicht mit dem Wert "{3}" f\u00FCr den festen effektiven Werte-Constraint der \u00FCbereinstimmenden Attributverwendung im Basistyp konsistent.
        derivation-ok-restriction.2.2.a = derivation-ok-restriction.2.2.a: Fehler bei Typ "{0}". Attributverwendung "{1}" in diesem Typ hat keine \u00FCbereinstimmende Attributverwendung in der Basis, und der Basistyp hat kein Platzhalterattribut.
        derivation-ok-restriction.2.2.b = derivation-ok-restriction.2.2.b: Fehler bei Typ "{0}". Attributverwendung "{1}" in diesem Typ hat keine \u00FCbereinstimmende Attributverwendung in der Basis, und der Platzhalter im Basistyp l\u00E4sst den Namespace "{2}" dieser Attributverwendung nicht zu.
        derivation-ok-restriction.3 = derivation-ok-restriction.3: Fehler bei Typ "{0}". Bei Attributverwendung "{1}" im Basistyp ist REQUIRED "true", aber es ist keine \u00FCbereinstimmende Attributverwendung im abgeleiteten Typ vorhanden.
        derivation-ok-restriction.4.1 = derivation-ok-restriction.4.1: Fehler bei Typ "{0}". Ableitung hat einen Attributplatzhalter, aber die Basis hat keinen.
        derivation-ok-restriction.4.2 = derivation-ok-restriction.4.2: Fehler bei Typ "{0}". Platzhalter in der Ableitung ist keine g\u00FCltige Platzhalter-Teilmenge des Platzhalters in der Basis.
        derivation-ok-restriction.4.3 = derivation-ok-restriction.4.3: Fehler bei Typ "{0}". Prozesscontent des Platzhalters in der Ableitung ({1}) ist schw\u00E4cher als der Content in der Basis ({2}).
        derivation-ok-restriction.5.2.2.1 = derivation-ok-restriction.5.2.2.1: Fehler bei Typ "{0}". Einfacher Contenttyp dieses Typs "{1}" ist keine g\u00FCltige Einschr\u00E4nkung des einfachen Contenttyps der Basis "{2}".
        derivation-ok-restriction.5.3.2 = derivation-ok-restriction.5.3.2: Fehler bei Typ "{0}". Contenttyp dieses Typs ist leer, aber der Contenttyps der Basis "{1}" ist nicht leer oder kann nicht geleert werden.
        derivation-ok-restriction.5.4.1.2 = derivation-ok-restriction.5.4.1.2: Fehler bei Typ "{0}". Contenttyp dieses Typs ist "mixed", aber der Contenttyps der Basis "{1}" nicht.
        derivation-ok-restriction.5.4.2 = derivation-ok-restriction.5.4.2: Fehler bei Typ "{0}". Partikel des Typs ist keine g\u00FCltige Einschr\u00E4nkung des Partikels der Basis.
        enumeration-required-notation = enumeration-required-notation: NOTATION-Typ "{0}", der von {2} "{1}" verwendet wird, muss einen Enumerations-Facet-Wert haben, der die von diesem Typ verwendeten Notationselemente angibt.
        enumeration-valid-restriction = enumeration-valid-restriction: Enumerationswert "{0}" ist nicht im Wertebereich des Basistyps {1} vorhanden.
        e-props-correct.2 = e-props-correct.2: Ung\u00FCltiger Werte-Constraint-Wert "{1}" in Element "{0}".
        e-props-correct.4 = e-props-correct.4: "{"type definition"}" von Element "{0}" wurde nicht auf g\u00FCltige Weise von der "{"type definition"}" von substitutionHead "{1}" abgeleitet, oder die "{"substitution group exclusions"}"-Eigenschaft von "{1}" l\u00E4sst diese Ableitung nicht zu.
        e-props-correct.5 = e-props-correct.5: "{"value constraint"}" darf nicht bei Element "{0}" vorhanden sein, da die "{"type definition"}" des Elements oder der "{"content type"}" der "{"type definition"}" ID ist oder von ID abgeleitet wurde.
        e-props-correct.6 = e-props-correct.6: Zyklische Substitutionsgruppe f\u00FCr Element "{0}" ermittelt.
        fractionDigits-valid-restriction = fractionDigits-valid-restriction: In der Definition von {2} ist der Wert "{0}" f\u00FCr Facet "fractionDigits" ung\u00FCltig, da er <= dem Wert f\u00FCr "fractionDigits" sein muss, der in einem der Vorg\u00E4ngertypen auf "{1}" gesetzt wurde.
        fractionDigits-totalDigits = fractionDigits-totalDigits: In der Definition von {2} ist der Wert "{0}" f\u00FCr Facet "fractionDigits" ung\u00FCltig, da der Wert <= dem Wert f\u00FCr "totalDigits" sein muss, der "{1}" ist.
        length-minLength-maxLength.1.1 = length-minLength-maxLength.1.1: Bei Typ {0} gilt es als Fehler, wenn der Wert von length "{1}" kleiner als der Wert von minLength "{2}" ist.
        length-minLength-maxLength.1.2.a = length-minLength-maxLength.1.2.a: Bei Typ {0} gilt es als Fehler, wenn die Basis kein minLength-Facet hat, wenn die aktuelle Einschr\u00E4nkung das minLength-Facet und die aktuelle Einschr\u00E4nkung oder Basis das length-Facet hat.
        length-minLength-maxLength.1.2.b = length-minLength-maxLength.1.2.b: Bei Typ {0} gilt es als Fehler, wenn die aktuelle minLength "{1}" nicht mit der Basis-minLength "{2}" identisch ist.
        length-minLength-maxLength.2.1 = length-minLength-maxLength.2.1: Bei Typ {0} gilt es als Fehler, wenn der Wert von length "{1}" gr\u00F6\u00DFer als der Wert von maxLength "{2}" ist.
        length-minLength-maxLength.2.2.a = length-minLength-maxLength.2.2.a: Bei Typ {0} gilt es als Fehler, wenn die Basis kein maxLength-Facet hat, wenn die aktuelle Einschr\u00E4nkung das maxLength-Facet und die aktuelle Einschr\u00E4nkung oder Basis das length-Facet hat.
        length-minLength-maxLength.2.2.b = length-minLength-maxLength.2.2.b: Bei Typ {0} gilt es als Fehler, wenn die aktuelle maxLength "{1}" nicht mit der Basis-maxLength "{2}" identisch ist.
        length-valid-restriction = length-valid-restriction: Fehler bei Typ "{2}". Der Wert von length = "{0}" muss mit dem Wert des Basistyps "{1}" identisch sein.
        maxExclusive-valid-restriction.1 = maxExclusive-valid-restriction.1: Fehler bei Typ "{2}". maxExclusive-Wert ="{0}" muss <= maxExclusive des Basistyps "{1}" sein.
        maxExclusive-valid-restriction.2 = maxExclusive-valid-restriction.2: Fehler bei Typ "{2}". maxExclusive-Wert ="{0}" muss <= maxInclusive des Basistyps "{1}" sein.
        maxExclusive-valid-restriction.3 = maxExclusive-valid-restriction.3: Fehler bei Typ "{2}". maxExclusive-Wert ="{0}" muss > minInclusive des Basistyps "{1}" sein.
        maxExclusive-valid-restriction.4 = maxExclusive-valid-restriction.4: Fehler bei Typ "{2}". maxExclusive-Wert ="{0}" muss > minExclusive des Basistyps "{1}" sein.
        maxInclusive-maxExclusive = maxInclusive-maxExclusive: Es gilt als Fehler, wenn sowohl maxInclusive als auch maxExclusive f\u00FCr denselben Datentyp angegeben werden. In {2} gilt: maxInclusive = "{0}" und maxExclusive = "{1}".
        maxInclusive-valid-restriction.1 = maxInclusive-valid-restriction.1: Fehler bei Typ "{2}". maxInclusive-Wert ="{0}" muss <= maxInclusive des Basistyps "{1}" sein.
        maxInclusive-valid-restriction.2 = maxInclusive-valid-restriction.2: Fehler bei Typ "{2}". maxInclusive-Wert ="{0}" muss < maxExclusive des Basistyps "{1}" sein.
        maxInclusive-valid-restriction.3 = maxInclusive-valid-restriction.3: Fehler bei Typ "{2}". maxInclusive-Wert ="{0}" muss >= maxInclusive des Basistyps "{1}" sein.
        maxInclusive-valid-restriction.4 = maxInclusive-valid-restriction.4: Fehler bei Typ "{2}". maxInclusive-Wert ="{0}" muss > minExclusive des Basistyps "{1}" sein.
        maxLength-valid-restriction = maxLength-valid-restriction: In der Definition von {2} muss maxLength-Wert = "{0}" <= dem Wert des Basistyps "{1}" sein.
        mg-props-correct.2 = mg-props-correct.2: Zyklische Definitionen f\u00FCr Gruppe "{0}" ermittelt. Rekursives Folgen der "{"term"}"-Werte der Partikel f\u00FChrt zu einem Partikel, dessen "{"term"}" die Gruppe selbst ist.
        minExclusive-less-than-equal-to-maxExclusive = minExclusive-less-than-equal-to-maxExclusive: In der Definition von {2} muss minExclusive-Wert = "{0}" <= maxExclusive-Wert = "{1}" sein.
        minExclusive-less-than-maxInclusive = minExclusive-less-than-maxInclusive: In der Definition von {2} muss minExclusive-Wert = "{0}" < maxInclusive-Wert = "{1}" sein.
        minExclusive-valid-restriction.1 = minExclusive-valid-restriction.1: Fehler bei Typ "{2}". minExclusive-Wert ="{0}" muss >= minExclusive des Basistyps "{1}" sein.
        minExclusive-valid-restriction.2 = minExclusive-valid-restriction.2: Fehler bei Typ "{2}". minExclusive-Wert ="{0}" muss <= maxInclusive des Basistyps "{1}" sein.
        minExclusive-valid-restriction.3 = minExclusive-valid-restriction.3: Fehler bei Typ "{2}". minExclusive-Wert ="{0}" muss >= minInclusive des Basistyps "{1}" sein.
        minExclusive-valid-restriction.4 = minExclusive-valid-restriction.4: Fehler bei Typ "{2}". minExclusive-Wert ="{0}" muss < maxExclusive des Basistyps "{1}" sein.
        minInclusive-less-than-equal-to-maxInclusive = minInclusive-less-than-equal-to-maxInclusive: In der Definition von {2} muss minInclusive-Wert = "{0}" <= maxInclusive-Wert = "{1}" sein.
        minInclusive-less-than-maxExclusive = minInclusive-less-than-maxExclusive: In der Definition von {2} muss minInclusive-Wert = "{0}" < maxExclusive-Wert = "{1}" sein.
        minInclusive-minExclusive = minInclusive-minExclusive: Es gilt als Fehler, wenn sowohl minInclusive als auch minExclusive f\u00FCr denselben Datentyp angegeben werden. In {2} gilt: minInclusive = "{0}" und minExclusive = "{1}".
        minInclusive-valid-restriction.1 = minInclusive-valid-restriction.1: Fehler bei Typ "{2}". minInclusive-Wert ="{0}" muss >= minInclusive des Basistyps "{1}" sein.
        minInclusive-valid-restriction.2 = minInclusive-valid-restriction.2: Fehler bei Typ "{2}". minInclusive-Wert ="{0}" muss <= maxInclusive des Basistyps "{1}" sein.
        minInclusive-valid-restriction.3 = minInclusive-valid-restriction.3: Fehler bei Typ "{2}". minInclusive-Wert ="{0}" muss > minExclusive des Basistyps "{1}" sein.
        minInclusive-valid-restriction.4 = minInclusive-valid-restriction.4: Fehler bei Typ "{2}". minInclusive-Wert ="{0}" muss < maxExclusive des Basistyps "{1}" sein.
        minLength-less-than-equal-to-maxLength = minLength-less-than-equal-to-maxLength: In der Definition von {2} muss der Wert von minLength = "{0}" < dem Wert von maxLength = "{1}" sein.
        minLength-valid-restriction = minLength-valid-restriction: In der Definition von {2} muss minLength = "{0}" >= dem Wert des Basistyps "{1}" sein.
        no-xmlns = no-xmlns: {name} einer Attributdeklaration darf nicht mit "xmlns" \u00FCbereinstimmen.
        no-xsi = no-xsi: "{"target namespace"}" einer Attributdeklaration darf nicht mit "{0}" \u00FCbereinstimmen.
        p-props-correct.2.1 = p-props-correct.2.1: In der Deklaration von "{0}" ist der Wert von "minOccurs" "{1}", er darf aber nicht gr\u00F6\u00DFer als der Wert von "maxOccurs" sein, der "{2}" lautet.
        rcase-MapAndSum.1 = rcase-MapAndSum.1: Es ist keine vollst\u00E4ndige Funktionszuordnung zwischen den Partikeln vorhanden.
        rcase-MapAndSum.2 = rcase-MapAndSum.2: Vorkommensbereich der Gruppe ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
        rcase-NameAndTypeOK.1 = rcase-NameAndTypeOK.1: Elemente haben Namen und Ziel-Namespaces, die nicht identisch sind: Element "{0}" in Namespace "{1}" und Element "{2}" in Namespace "{3}".
        rcase-NameAndTypeOK.2 = rcase-NameAndTypeOK.2: Fehler beim Partikel, dessen "{"term"}" die Elementdeklaration "{0}" ist. "{"nillable"}" ist bei der Elementdeklaration "true", aber das entsprechende Partikel im Basistyp hat eine Elementdeklaration, bei der "{"nillable"}" "false" ist.
        rcase-NameAndTypeOK.3 = rcase-NameAndTypeOK.3: Fehler beim Partikel, dessen "{"term"}" die Elementdeklaration "{0}" ist. Der Vorkommensbereich ({1},{2}) ist keine g\u00FCltige Einschr\u00E4nkung des Bereichs ({3},{4}) des entsprechenden Partikels im Basistyp.
        rcase-NameAndTypeOK.4.a = rcase-NameAndTypeOK.4.a: Element "{0}" ist nicht fest, aber das entsprechende Element im Basistyp ist fest mit Wert "{1}".
        rcase-NameAndTypeOK.4.b = rcase-NameAndTypeOK.4.b: Element "{0}" ist fest mit dem Wert "{1}", aber das entsprechende Element im Basistyp ist fest mit Wert "{2}".
        rcase-NameAndTypeOK.5 = rcase-NameAndTypeOK.5: Identity Constraints f\u00FCr Element "{0}" sind keine Teilmenge der Constraints in der Basis.
        rcase-NameAndTypeOK.6 = rcase-NameAndTypeOK.6: Die unzul\u00E4ssigen Substitutionen f\u00FCr Element "{0}" sind keine Obermenge der Substitutionen in der Basis.
        rcase-NameAndTypeOK.7 = rcase-NameAndTypeOK.7: Typ des Elements "{0}" "{1}" wurde nicht vom Typ des Basiselements "{2}" abgeleitet.
        rcase-NSCompat.1 = rcase-NSCompat.1: Element "{0}" hat den Namespace "{1}". Dies wird vom Platzhalter in der Basis nicht zugelassen.
        rcase-NSCompat.2 = rcase-NSCompat.2: Fehler beim Partikel, dessen "{"term"}" die Elementdeklaration "{0}" ist. Der Vorkommensbereich ({1},{2}) ist keine g\u00FCltige Einschr\u00E4nkung des Bereichs ({3},{4}) des entsprechenden Partikels im Basistyp.
        rcase-NSRecurseCheckCardinality.1 = rcase-NSRecurseCheckCardinality.1: Es ist keine vollst\u00E4ndige Funktionszuordnung zwischen den Partikeln vorhanden.
        rcase-NSRecurseCheckCardinality.2 = rcase-NSRecurseCheckCardinality.2: Vorkommensbereich der Gruppe ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Bereichs des Basisplatzhalters ({2},{3}).
        rcase-NSSubset.1 = rcase-NSSubset.1: Platzhalter ist keine Teilmenge des entsprechenden Platzhalters in der Basis.
        rcase-NSSubset.2 = rcase-NSSubset.2: Vorkommensbereich des Platzhalters ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Bereichs in der Basis ({2},{3}).
        rcase-NSSubset.3 = rcase-NSSubset.3: Prozesscontent des Platzhalters ("{0}") ist schw\u00E4cher als der in der Basis "{1}".
        rcase-Recurse.1 = rcase-Recurse.1: Vorkommensbereich der Gruppe ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
        rcase-Recurse.2 = rcase-Recurse.2: Es ist keine vollst\u00E4ndige Funktionszuordnung zwischen den Partikeln vorhanden.
        rcase-RecurseLax.1 = rcase-RecurseLax.1: Vorkommensbereich der Gruppe ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
        rcase-RecurseLax.2 = rcase-RecurseLax.2: Es ist keine vollst\u00E4ndige Funktionszuordnung zwischen den Partikeln vorhanden.
        rcase-RecurseUnordered.1 = rcase-RecurseUnordered.1: Vorkommensbereich der Gruppe ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
        rcase-RecurseUnordered.2 = rcase-RecurseUnordered.2: Es ist keine vollst\u00E4ndige Funktionszuordnung zwischen den Partikeln vorhanden.
#        We"re using sch-props-correct.2 instead of the old src-redefine.1
#        src-redefine.1 = src-redefine.1: The component "{0}" is begin redefined, but its corresponding component isn"t in the schema document being redefined (with namespace "{2}"), but in a different document, with namespace "{1}".
        sch-props-correct.2 = sch-props-correct.2: Ein Schema kann nicht zwei globale Komponenten mit demselben Namen enthalten. Dieses Schema enth\u00E4lt zwei Vorkommen von "{0}".
        st-props-correct.2 = st-props-correct.2: Zyklische Definitionen wurden f\u00FCr Simple Type "{0}" ermittelt. Dies bedeutet, dass "{0}" in der eigenen Typhierarchie enthalten ist. Dies ist ein Fehler.
        st-props-correct.3 = st-props-correct.3: Fehler bei Typ "{0}". Der Wert von "{"final"}" der "{"base type definition"}" "{1}" l\u00E4sst keine Ableitung durch Einschr\u00E4nkung zu.
        totalDigits-valid-restriction = totalDigits-valid-restriction: In der Definition von {2} ist der Wert "{0}" f\u00FCr Facet "totalDigits" ung\u00FCltig, da er <= dem Wert f\u00FCr "totalDigits" sein muss, der in einem der Vorg\u00E4ngertypen auf "{1}" gesetzt wurde.
        whiteSpace-valid-restriction.1 = whiteSpace-valid-restriction.1: In der Definition von {0} ist der Wert "{1}" f\u00FCr Facet "whitespace" ung\u00FCltig, da der Wert f\u00FCr "whitespace" in einem der Vorg\u00E4ngertypen auf "collapse" gesetzt wurde.
        whiteSpace-valid-restriction.2 = whiteSpace-valid-restriction.2: In der Definition von {0} ist der Wert "preserve" f\u00FCr Facet "whitespace" ung\u00FCltig, da der Wert f\u00FCr "whitespace" in einem der Vorg\u00E4ngertypen auf "replace" gesetzt wurde.

#schema for Schemas

        s4s-att-invalid-value = s4s-att-invalid-value: Ung\u00FCltiger Attributwert f\u00FCr "{1}" in Element "{0}". Aufgezeichneter Grund: {2}
        s4s-att-must-appear = s4s-att-must-appear: Attribut "{1}" muss in Element "{0}" vorkommen.
        s4s-att-not-allowed = s4s-att-not-allowed: Attribut "{1}" darf nicht in Element "{0}" vorkommen.
        s4s-elt-invalid = s4s-elt-invalid: Element "{0}" ist kein g\u00FCltiges Element in einem Schemadokument.
        s4s-elt-must-match.1 = s4s-elt-must-match.1: Content von "{0}" muss {1} entsprechen. Beim Start bei {2} ist ein Problem aufgetreten.
        s4s-elt-must-match.2 = s4s-elt-must-match.2: Content von "{0}" muss {1} entsprechen. Nicht gen\u00FCgend Elemente gefunden.
        # the "invalid-content" messages provide less information than the "must-match" counterparts above. They"re used for complex types when providing a "match" would be an information dump
        s4s-elt-invalid-content.1 = s4s-elt-invalid-content.1: Content von "{0}" ist ung\u00FCltig. Element "{1}" ist ung\u00FCltig, nicht an der erwarteten Stelle oder kommt zu oft vor.
        s4s-elt-invalid-content.2 = s4s-elt-invalid-content.2: Content von "{0}" ist ung\u00FCltig. Element "{1}" darf nicht leer sein.
        s4s-elt-invalid-content.3 = s4s-elt-invalid-content.3: Elemente mit dem Typ "{0}" k\u00F6nnen nicht nach Deklarationen als untergeordnete Elemente eines <schema>-Elements vorkommen.
        s4s-elt-schema-ns = s4s-elt-schema-ns: Namespace des Elements "{0}" muss aus dem Schema-Namespace "http://www.w3.org/2001/XMLSchema" stammen.
        s4s-elt-character = s4s-elt-character: In anderen Schemaelementen als "xs:appinfo" und "xs:documentation" sind nur Leerstellen zul\u00E4ssig. "{0}" gefunden.

# codes not defined by the spec

        c-fields-xpaths = c-fields-xpaths: Feldwert = "{0}" ist ung\u00FCltig.
        c-general-xpath = c-general-xpath: Ausdruck "{0}" ist ung\u00FCltig in Bezug auf die vom XML-Schema unterst\u00FCtzte XPath-Teilmenge.
        c-general-xpath-ns = c-general-xpath-ns: Namespace-Pr\u00E4fix in XPath-Ausdruck "{0}" war an einen Namespace gebunden.
        c-selector-xpath = c-selector-xpath: Selektor-Wert = "{0}" ist ung\u00FCltig. Selektor-XPaths k\u00F6nnen keine Attribute enthalten.
        EmptyTargetNamespace = EmptyTargetNamespace: In Schemadokument "{0}" kann der Wert des "targetNamespace"-Attributs keine leere Zeichenfolge sein.
        FacetValueFromBase = FacetValueFromBase: In der Deklaration von Typ "{0}" muss der Wert "{1}" von Facet "{2}" aus dem Wertebereich des Basistyps "{3}" stammen.
        FixedFacetValue = FixedFacetValue: In der Definition von {3} ist der Wert "{1}" f\u00FCr Facet "{0}" ung\u00FCltig, da der Wert f\u00FCr "{0}" in einem der Vorg\u00E4ngertypen auf "{2}" gesetzt wurde und "{"fixed"}"" = true ist.
        InvalidRegex = InvalidRegex: Musterwert "{0}" ist kein g\u00FCltiger regul\u00E4rer Ausdruck. Der gemeldete Fehler war: "{1}" bei Spalte "{2}".
        MaxOccurLimit = Aktuelle Konfiguration des Parsers l\u00E4sst nicht zu, dass ein maxOccurs-Attributwert auf einen h\u00F6heren Wert als {0} gesetzt wird.
        PublicSystemOnNotation = PublicSystemOnNotation: Mindestens eines der Elemente "public" und "system" muss im Element "notation" vorkommen.
        SchemaLocation = SchemaLocation: schemaLocation-Wert = "{0}" muss eine gerade Anzahl an URIs haben.
        TargetNamespace.1 = TargetNamespace.1: Namespace "{0}" wird erwartet, aber der Ziel-Namespace des Schemadokuments ist "{1}".
        TargetNamespace.2 = TargetNamespace.2: Kein Namespace wird erwartet, aber das Schemadokument hat den Ziel-Namespace "{1}".
        UndeclaredEntity = UndeclaredEntity: Entity "{0}" ist nicht deklariert.
        UndeclaredPrefix = UndeclaredPrefix: "{0}" kann nicht als QName aufgel\u00F6st werden: Pr\u00E4fix "{1}" ist nicht deklariert.


# JAXP 1.2 schema source property errors

        jaxp12-schema-source-type.1 = Die Eigenschaft "http://java.sun.com/xml/jaxp/properties/schemaSource" darf keinen Wert des Typs "{0}" haben. M\u00F6gliche unterst\u00FCtzte Werttypen sind String, File, InputStream, InputSource oder ein Array dieser Typen.
        jaxp12-schema-source-type.2 = Die Eigenschaft "http://java.sun.com/xml/jaxp/properties/schemaSource" darf keinen Arraywert des Typs "{0}" haben. M\u00F6gliche unterst\u00FCtzte Arraytypen sind Object, String, File, InputStream, InputSource.
        jaxp12-schema-source-ns = Bei Verwendung eines Arrays von Objects als Wert der Eigenschaft "http://java.sun.com/xml/jaxp/properties/schemaSource" d\u00FCrfen keine zwei Schemas denselben Ziel-Namespace verwenden.

# Additions for XML Schema 1.1 support

cvc-datatype-valid.1.2.4 = cvc-datatype-valid.1.2.4: Der zur Validierung von "{1}" verwendete NOTATION-Typ "{0}" muss einen Enumerationsfacet-Wert besitzen, der die von diesem Typ verwendeten Notation-Elemente angibt.
cvc-assertion = cvc-assertion: Die Assertion-Auswertung ("{1}") fr das Element "{0}" im Schema-Typ "{2}" war nicht erfolgreich. {3}
cvc-assertion-failure-mesg = cvc-assertion-failure-mesg: {0} {1}
cvc-assertions-valid = cvc-assertions-valid: Der Wert "{0}" ist bezglich der Assertion "{1}" nicht facet-gltig. {2}
cvc-assertions-valid-union-elem = cvc-assertions-valid-union-elem: Der Wert "{0}" ist bezglich der angegebenen Zusicherungen fr den Typ "{2}" im Element "{1}" nicht facettenkonform.
cvc-assertions-valid-union-attr = cvc-assertions-valid-union-attr: Der Wert "{0}" ist bezglich der angegebenen Zusicherungen fr den Typ "{3}" im Attribut "{2}"/@"{1}" nicht facettenkonform.
cvc-xpath.3.13.4.2a = cvc-xpath.3.13.4.2a: XPST0003  Der XPath-Ausdruck fr die Zusicherung ("{0}") im Schematyp "{1}" konnte nicht erfolgreich kompiliert werden.
cvc-xpath.3.13.4.2b = cvc-xpath.3.13.4.2b: Ein Assert-XPath-Ausdruck wie ("{0}"), der mit / oder // beginnt, ist fr den Schematyp "{1}" nicht zulssig (da ein Assert-XPath-Baum an einem Element ohne bergeordnetes Element beginnt).
src-attribute.5 = src-attribute.5: Die Eigenschaft "fixed" ist im Attribut "{0}" vorhanden, daher darf der Wert von "use" nicht "prohibited" sein.
src-attribute.6.2 = src-attribute.6.2: Da das Attribut "{0}" das Attribut "targetNamespace" enthlt, darf das Attribut "form" nicht vorhanden sein.
src-attribute.6.3.1 = src-attribute.6.3.1: Da das Attribut "{0}" das Attribut "targetNamespace" enthlt und <schema> kein "targetNamespace"-Attribut besitzt oder dessen Wert sich vom Wert von "targetNamespace" in "{0}" unterscheidet, muss "{0}" ein <complexType> als Vorfahren haben.
src-attribute.6.3.2 = src-attribute.6.3.2: Da das Attribut "{0}" das Attribut "targetNamespace" enthlt und <schema> kein "targetNamespace"-Attribut besitzt oder dessen Wert sich vom Wert von "targetNamespace" in "{0}" unterscheidet, muss zwischen "{0}" und dem nchstgelegenen <complexType>-Vorfahren ein <restriction>-Vorfahre liegen, und der Wert des "base"-Attributs von <restriction> stimmt nicht mit dem Namen von "xs:anyType" berein.
src-ct.6 = src-ct.5: Darstellungsfehler der komplexen Typdefinition fr den Typ "{0}". Wenn <openContent> vorhanden ist und der tatschliche Wert seines Modus-Attributs nicht "none" ist, muss ein <any> unter den [Kindern] von <openContent> vorhanden sein.
src-ct.7 = src-ct.7: Die Attributgruppe "{0}" ist innerhalb einer komplexen Typdefinition "{1}" mehrfach deklariert.
src-ct11.3 = src-ct11.3: Darstellungsfehler der komplexen Typdefinition fr den Typ "{0}". Wenn <openContent> vorhanden ist und den Modus "none" hat, darf kein <any> unter den [Kindern] von <openContent> vorhanden sein.
src-ct11.4 = src-ct11.4: Darstellungsfehler der komplexen Typdefinition fr den Typ "{0}". Wenn die Alternative <complexContent> gewhlt wird und das Attribut "mixed" sowohl bei <complexType> als auch bei <complexContent> vorhanden ist, dann mssen die tatschlichen Werte dieser Attribute gleich sein.
src-element.4.2 = src-element.4.2: Da das Element "{0}" das Attribut "targetNamespace" enthlt, darf das Attribut "form" nicht vorhanden sein.
src-element.4.3.1 = src-element.4.3.1: Da das Element "{0}" das Attribut "targetNamespace" enthlt und <schema> kein "targetNamespace"-Attribut besitzt oder dessen Wert sich vom Wert von "targetNamespace" in "{0}" unterscheidet, muss "{0}" ein <complexType> als bergeordnetes Element haben.
src-element.4.3.2 = src-element.4.3.2: Da das Element "{0}" das Attribut "targetNamespace" enthlt und <schema> kein "targetNamespace"-Attribut besitzt oder dessen Wert sich vom Wert von "targetNamespace" in "{0}" unterscheidet, muss zwischen "{0}" und dem nchstgelegenen <complexType>-Vorfahren ein <restriction>-Element vorhanden sein, und der Wert des "base"-Attributs von <restriction> stimmt nicht mit dem Namen von "xs:anyType" berein.
src-element.5 = src-element.5: Das Element "{0}" besitzt eine Typalternative ohne das Attribut "test". Nur die letzte Typalternative in der Typtabelle darf kein "test"-Attribut besitzen.
src-identity-constraint.1 = src-identity-constraint.1: In einer Identittseinschrnkungsdeklaration muss entweder "ref" oder "name" vorhanden sein.
src-identity-constraint.5 = src-identity-constraint.5: Die Identittsbeschrnkungskategorie der durch den tatschlichen Wert des Attributs ref aufgelsten Identittsbeschrnkungsdefinition stimmt nicht mit dem Namen des Elementinformationselements {0} berein.
src-override.2.1 = src-override.2.1: Der Ziel-Namespace des berschriebenen Schemas, aktuell {1}, muss mit dem des berschreibenden Schemas, aktuell {0}, identisch sein.
src-override-collision.1 = src-override-collision.1: Die Schema-ID {0}, auf die <{1}> verweist, kollidiert mit einem bereits berschriebenen Schema. Das referenzierte Schema wird ignoriert.
src-override-collision.2 = src-override-collision.2: Die berschreibungstransformation des Schemas mit der ID "{0}" kollidiert mit einem bestehenden Schema, das zuvor eingebunden, neu definiert oder berschrieben wurde. Das transformierte Schema wird ignoriert, und die berschreibung findet nicht statt.
src-type-alternative.3.12.13.1 = src-type-alternative.3.12.13.1: Die Typalternative besitzt sowohl ein Attribut vom Typ " als auch ein Kindelement vom Typ "anonymous type". Fr eine Typalternative ist nur eines von beiden zulssig.
src-type-alternative.3.12.13.2 = src-type-alternative.3.12.13.2: Fr die Typalternative fehlt die Typdefinition. Es muss ein Attribut vom Typ "type", ein Kindelement vom Typ "complexType" oder ein Kindelement vom Typ "simpleType" vorhanden sein.
src-wildcard.1 = src-wildcard.1: Die Eigenschaften namespace und notNamespace drfen nicht beide in einer Wildcard-Deklaration vorhanden sein. Verwenden Sie nur eine davon.
src-cip.1 = src-cip.1: Das Attribut "{0}" gehrt nicht zum Schema-Versionierungs-Namensraum (http://www.w3.org/2007/XMLSchema-versioning). Fr den Schema-Versionierungs-Namensraum sind nur die folgenden Attribute verfgbar: "minVersion", "maxVersion", "typeAvailable", "typeUnavailable", "facetAvailable" und "facetUnavailable".
src-assert.3.13.1 = src-assert.3.13.1: Das obligatorische Attribut "test" ist im Element "{0}" innerhalb der Typdefinition "{1}" nicht vorhanden.
cos-all-limited.1.3 = cos-all-limited.1.3: Wenn ein xs:group-Partikel als Kind von xs:all auftritt, muss fr das xs:group-Partikel die folgende Bedingung gelten: "{"min occurs"}" = "{"max occurs"}" = 1.
cos-all-limited.2-xs11 = cos-all-limited.2-xs11: Die Schemaanweisung "{0}" wurde als Kind von "xs:group" gefunden, auf das durch diese Gruppenreferenz verwiesen wird. Gruppen, auf die von "xs:all" verwiesen wird, drfen selbst nur "xs:all" enthalten.
cos-ct-extends.1.4.3.2.2.3 = cos-ct-extends.1.4.3.2.2.3: Der offene Inhalt des Basistyps fehlt nicht, und der Inhaltstyp des abgeleiteten Typs muss den Modus "suffix" oder "interleave" haben. Der Typ "{0}" hat einen offenen Inhalt mit dem Modus "none".
cos-ct-extends.1.4.3.2.2.3.3 = cos-ct-extends.1.4.3.2.2.3.3: Der offene Inhalt eines abgeleiteten Typs und der seines Basistyps mssen beide den Modus "suffix" haben. Der Typ "{0}" hat einen offenen Inhalt mit dem Modus "suffix", sein Basistyp jedoch nicht.
cos-ct-extends.1.4.3.2.2.3.4 = cos-ct-extends.1.4.3.2.2.3.4: Die Namensraumbeschrnkung des Wildcards im offenen Inhalt des Basistyps muss eine Teilmenge der Namensraumbeschrnkung des Wildcards im offenen Inhalt des abgeleiteten Typs sein. Dies ist fr den Typ "{0}" nicht der Fall.
cos-element-consistent.4.a = cos-element-consistent.4: Ein Platzhalter hat ein globales Element "{0}" gefunden, dessen Typ "{1}" nicht gltig von der Typdefinition "{2}" eines lokalen Elements mit demselben Namen abgeleitet werden kann.
cos-element-consistent.4.b = cos-element-consistent.4: Fehler fr Typ "{0}". In der Modellgruppe sind mehrere Elemente mit dem Namen "{1}" vorhanden, deren Typtabellen nicht quivalent sind.
cos-content-act-restrict.5.3 = cos-content-act-restrict.5.3: Fehler fr Typ "{0}". Das Attribut use "{1}" hat in diesem Typ den Wert "inheritable", was nicht mit dem Wert im Basistyp bereinstimmt.
cos-particle-extends.3.1 = cos-particle-extends.3.1: Wenn sowohl ein abgeleiteter Typ als auch seine Basis Partikel mit <all> als ihren "{"term"}"s haben, muss minOccurs des abgeleiteten Partikels gleich dem seiner Basis sein.
e-props-correct.7 = e-props-correct.7: Der Typalternative "{1}" ist nicht xs:error oder nicht gltig von der Typdefinition "{2}" des Elements "{0}" abgeleitet.
st-props-correct.1 = st-props-correct.1: "itemType" von xs:list und "memberTypes" von xs:union drfen nicht auf die speziellen Typen xs:anyAtomicType oder xs:anySimpleType verweisen. Die Komponente "{1}" von simpleType "{0}" verletzt diese Einschrnkung.
wc-props-correct.2 = wc-props-correct.2: Wenn ein Wildcard-Attribut die {variety} "not" enthlt, mssen die {namespaces} mindestens ein Element haben.
wc-props-correct.4 = wc-props-correct.4: Der Namespace "{0}" fr den unzulssigen Namen "{1}" ist durch das Wildcard-Zeichen nicht zulssig.
minScale-totalDigits = minScale-totalDigits: In der Definition von {2} muss der Wert von minScale = "{0}" kleiner oder gleich dem Wert von maxScale = "{1}" sein.
cvc-maxScale-valid = cvc-maxScale-valid: Fr den Typ {2} und den Wert {0} ist es ein Fehler, wenn der Wert der Genauigkeit "{3}" grer als der Wert von maxScale "{1}" ist.
cvc-minScale-valid = cvc-minScale-valid: Fr den Typ {2} und den Wert {0} ist es ein Fehler, wenn der Wert der Genauigkeit "{3}" kleiner als der Wert von minScale "{1}" ist.
cvc-explicitTimezone-valid = cvc-explicitTimezone-valid: Der Wert "{0}" ist bezglich der expliziten Zeitzone "{1}" fr den Typ "{2}" nicht facettenkonform.
maxScale-valid-restriction = maxScale-valid-restriction: In der Definition von {2} muss der Wert von maxScale = "{0}" kleiner oder gleich dem des Basistyps "{1}" sein.
minScale-valid-restriction = minScale-valid-restriction: In der Definition von {2} muss der Wert von minScale = "{0}" grer oder gleich dem des Basistyps "{1}" sein.
timezone-valid-restriction = timezone-valid-restriction: In der Definition von {0} ist der Wert "{1}" fr die Facette "explicitTimezone" ungltig, da der Wert fr "explicitTimezone" in einem der bergeordneten Typen auf "{2}" gesetzt wurde.
c-cta-xpath = c-cta-xpath: Der XPath-Ausdruck "{0}" konnte whrend der CTA-Auswertung im "{1}"-Modus nicht erfolgreich kompiliert werden.
c-cta-xpath-b = c-cta-xpath-b: Der CTA-XPath-Ausdruck ("{0}"), der mit / oder // beginnt, ist im "{1}"-Modus nicht zulssig (da ein CTA-XPath-Baum an einem Element ohne bergeordnetes Element verwurzelt ist).
c-cta-xpath-serr = c-cta-xpath-serr: Der XPath-Ausdruck "{0}" konnte whrend der CTA-Auswertung im Modus "{1}" nicht erfolgreich kompiliert werden. Im XPath-Ausdruck ist ein statischer Fehler "{2}" aufgetreten.
