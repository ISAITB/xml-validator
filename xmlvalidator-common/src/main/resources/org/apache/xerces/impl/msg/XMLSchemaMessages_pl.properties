BadMessageKey =Nie można znaleźć komunikatu o błędzie odpowiadającego kluczowi wiadomości.
FormatFailed =Wystąpił błąd wewnętrzny podczas formatowania następującego komunikatu:
Internal-Error =Błąd wewnętrzny: {0}.
dt-whitespace =Wartość aspektu odstępu nie jest dostępna dla unii simpleType "{0}”
GrammarConflict =Jedna z gramatyk zwróconych z puli gramatyki użytkownika jest w konflikcie z inną gramatykią.
AbsentKeyValue =cvc-identity-constraint.4.2.1.a: Element "{0}" nie ma wartości dla klucza "{1}".
DuplicateField =Zduplikowane dopasowanie w zakresie pola "{0}".
DuplicateKey =cvc-identity-constraint.4.2.2: Znaleziono zduplikowaną wartość klucza [{0}] dla ograniczenia tożsamości "{2}" elementu "{1}".
DuplicateUnique =cvc-identity-constraint.4.1: Zduplikowana unikalna wartość [{0}] została znaleziona dla ograniczenia tożsamości "{2}" elementu "{1}".
FieldMultipleMatch =cvc-identity-constraint.3: Pole "{0}" ograniczenia tożsamości "{1}" pasuje do więcej niż jednej wartości w zakresie selektora; pola muszą odpowiadać unikalnym wartościom.
FixedDiffersFromActual =Zawartość tego elementu nie jest równoważna wartości atrybutu "fixed" w deklaracji elementu w schemacie.
KeyMatchesNillable =cvc-identity-constraint.4.2.3: Element "{0}" ma klucz "{1}", który pasuje do elementu, który ma wartość nillable ustawioną na true.
KeyNotEnoughValues =cvc-identity-constraint.4.2.1.b: Nie określono wystarczającej liczby wartości dla <nazwa klucza="{1}"> ograniczenia tożsamości określonego dla elementu "{0}".
KeyNotFound =cvc-identity-constraint.4.3: Klucz "{0}" o wartości "{1}" nie został znaleziony dla ograniczenia tożsamości elementu "{2}".
KeyRefOutOfScope =Błąd ograniczenia tożsamości: ograniczenie tożsamości klucza "{0}” odnosi się do klucza lub unikatu, który jest poza zakresem.
KeyRefReferNotFound =Deklaracja referencji klucza "{0}" odnosi się do nieznanego klucza o nazwie "{1}".
UnknownField =Błąd wewnętrznego ograniczenia tożsamości; nieznane pole "{0}" dla ograniczenia tożsamości "{2}" określonego dla elementu "{1}".
cvc-attribute.3 =cvc-attribute.3: Wartość "{2}" atrybutu "{1}" w elemencie "{0}" jest nieprawidłowa w odniesieniu do jego typu "{3}".
cvc-attribute.4 =cvc-attribute.4: Wartość "{2}” atrybutu "{1}” w elemencie "{0}” jest nieprawidłowa w odniesieniu do jego stałego "{”ograniczenia wartości”}”. Atrybut musi mieć wartość "{3}”.
cvc-complex-type.2.1 =cvc-complex-type.2.1: Element "{0}" nie może mieć znaku ani elementu informacyjnego elementu [dzieci], ponieważ typ zawartości typu jest pusty.
cvc-complex-type.2.2 =cvc-complex-type.2.2: Element "{0}" nie może mieć elementu [dzieci], a wartość musi być prawidłowa.
cvc-complex-type.2.3 =cvc-complex-type.2.3: Element "{0}" nie może mieć znaku [dzieci], ponieważ typ zawartości typu to tylko element.
cvc-complex-type.2.4.a =cvc-complex-type.2.4.a: Znaleziono nieprawidłową treść zaczynającą się od elementu "{0}". Oczekiwany jest jeden z "{1}”.
cvc-complex-type.2.4.b =cvc-complex-type.2.4.b: Zawartość elementu "{0}" nie jest kompletna. Oczekiwany jest jeden z "{1}”.
cvc-complex-type.2.4.c =cvc-complex-type.2.4.c: Pasujący symbol wieloznaczny jest ścisły, ale nie można znaleźć deklaracji dla elementu "{0}”.
cvc-complex-type.2.4.d =cvc-complex-type.2.4.d: Znaleziono nieprawidłową treść rozpoczynającą się od elementu "{0}". W tym momencie nie oczekuje się żadnego elementu podrzędnego.
cvc-complex-type.2.4.e =cvc-complex-type.2.4.e: "{0}" może wystąpić maksymalnie "{2}" razy w bieżącej sekwencji. Ten limit został przekroczony. W tym momencie oczekiwany jest jeden z "{1}".
cvc-complex-type.2.4.f =cvc-complex-type.2.4.f: "{0}" może wystąpić maksymalnie "{1}" razy w bieżącej sekwencji. Ten limit został przekroczony. W tym momencie nie oczekuje się żadnego elementu podrzędnego.
cvc-complex-type.2.4.g =cvc-complex-type.2.4.g: znaleziono nieprawidłową treść zaczynającą się od elementu "{0}”. Oczekuje się, że "{1}" wystąpi co najmniej "{2}" razy w bieżącej sekwencji. Aby spełnić to ograniczenie, wymagana jest jeszcze jedna instancja.
cvc-complex-type.2.4.h =cvc-complex-type.2.4.h: Znaleziono nieprawidłową treść zaczynającą się od elementu "{0}". Oczekuje się, że "{1}" wystąpi co najmniej "{2}" razy w bieżącej sekwencji. "{3}" wymaga więcej wystąpień, aby spełnić to ograniczenie.
cvc-complex-type.2.4.i =cvc-complex-type.2.4.i: Zawartość elementu "{0}" nie jest kompletna. Oczekuje się, że "{1}" wystąpi co najmniej "{2}" razy. Aby spełnić to ograniczenie, wymagana jest jeszcze jedna instancja.
cvc-complex-type.2.4.j =cvc-complex-type.2.4.j: Zawartość elementu "{0}" nie jest kompletna. Oczekuje się, że "{1}" wystąpi co najmniej "{2}" razy. "{3}" wymaga więcej wystąpień, aby spełnić to ograniczenie.
cvc-complex-type.3.1 =cvc-complex-type.3.1: Wartość "{2}" atrybutu "{1}" elementu "{0}" jest nieprawidłowa w odniesieniu do odpowiedniego użycia atrybutu. Atrybut "{1}" ma stałą wartość "{3}".
cvc-complex-type.3.2.1 =cvc-complex-type.3.2.1: Element "{0}” nie ma atrybutu wieloznacznego dla atrybutu "{1}”.
cvc-complex-type.3.2.2 =cvc-complex-type.3.2.2: Atrybut "{1}” nie może pojawiać się w elemencie "{0}”.
cvc-complex-type.4 =cvc-complex-type.4: Atrybut "{1}” musi pojawić się w elemencie "{0}”.
cvc-complex-type.5.1 =cvc-complex-type.5.1: W elemencie "{0}” atrybut "{1}” jest Wild ID. Ale istnieje już Wild ID "{2}". Może być tylko jeden.
cvc-complex-type.5.2 =cvc-complex-type.5.2: W elemencie "{0}” atrybut "{1}” jest Wild ID. Ale istnieje już atrybut "{2}" pochodzący z ID wśród "{"atrybut używa"}".
cvc-datatype-valid.1.2.1 =cvc-datatype-valid.1.2.1: "{0}” nie jest prawidłową wartością dla "{1}”.
cvc-datatype-valid.1.2.2 =cvc-datatype-valid1.2.2: "{0}” nie jest prawidłową wartością typu listy "{1}”.
cvc-datatype-valid.1.2.3 =cvc-datatype-valid.1.2.3: "{0}” nie jest prawidłową wartością typu unii "{1}”.
cvc-elt.1.a =cvc-elt.1.a: Nie można znaleźć deklaracji elementu "{0}".
cvc-elt.1.b =cvc-elt.1.b: Nazwa elementu nie jest zgodna z nazwą deklaracji elementu. Widziałem "{0}”. Oczekiwany "{1}”.
cvc-elt.2 =cvc-elt.2: Wartość "{"abstract"}" w deklaracji elementu dla "{0}" musi być fałszem.
cvc-elt.3.1 =cvc-elt.3.1: Atrybut "{1}" nie może pojawić się w elemencie "{0}", ponieważ właściwość "{"nillable"}" "{0}" jest fałszywa.
cvc-elt.3.2.1 =cvc-elt.3.2.1: Element "{0}" nie może mieć informacji o znaku lub elemencie [dzieci], ponieważ określono "{1}".
cvc-elt.3.2.2 =cvc-elt.3.2.2: Nie może być ustalonego "{"ograniczenia wartości"}" dla elementu "{0}", ponieważ określono "{1}".
cvc-elt.4.1 =cvc-elt.4.1: Wartość "{2}" atrybutu "{1}" elementu "{0}" nie jest poprawną QName.
cvc-elt.4.2 =cvc-elt.4.2: Nie można przetłumaczyć "{1}" na definicję typu dla elementu "{0}".
cvc-elt.4.3 =cvc-elt.4.3: Typ "{1}” nie jest poprawnie wyprowadzony z definicji typu "{2}” elementu "{0}”.
cvc-elt.5.1.1 =cvc-elt.5.1.1: "{"ograniczenie wartości"}" "{2}" elementu "{0}" nie jest prawidłową wartością domyślną dla typu "{1}".
cvc-elt.5.2.2.1 =cvc-elt.5.2.2.1: Element "{0}" nie może zawierać elementu informacyjnego [dzieci].
cvc-elt.5.2.2.2.1 =cvc-elt.5.2.2.2.1: Wartość "{1}” elementu "{0}” nie jest zgodna ze stałą wartością "{”ograniczenie wartości”}” "{2}”.
cvc-elt.5.2.2.2.2 =cvc-elt.5.2.2.2.2: Wartość "{1}” elementu "{0}” nie jest zgodna z wartością "{”ograniczenie wartości”}” "{2}”.
cvc-enumeration-valid =cvc-enumeration-valid: wartość "{0}” nie jest poprawna dla aspektu w odniesieniu do wyliczenia "{1}”. Musi to być wartość z wyliczenia.
cvc-fractionDigits-valid =cvc-fractionDigits-valid: Wartość "{0}" ma {1} cyfr ułamkowych, ale liczba cyfr ułamkowych została ograniczona do {2}.
cvc-id.1 =cvc-id.1: Nie ma powiązania ID/IDREF dla IDREF "{0}".
cvc-id.2 =cvc-id.2: istnieje wiele wystąpień wartości identyfikatora "{0}”.
cvc-id.3 =cvc-id.3: pole ograniczenia tożsamości "{0}" dopasowane do elementu "{1}", ale ten element nie ma prostego typu.
cvc-length-valid =cvc-length-valid: Wartość "{0}" o długości = "{1}" nie jest prawidłowa aspektu w odniesieniu do długości "{2}" dla typu "{3}".
cvc-maxExclusive-valid =cvc-maxExclusive-valid: wartość "{0}” nie jest prawidłowa w odniesieniu do maxExclusive "{1}” dla typu "{2}”.
cvc-maxInclusive-valid =cvc-maxInclusive-valid: wartość "{0}” nie jest prawidłowa w odniesieniu do maxInclusive "{1}” dla typu "{2}”.
cvc-maxLength-valid =cvc-maxLength-valid: Wartość "{0}" o długości = "{1}" nie jest prawidłowa aspektu w odniesieniu do maxLength "{2}" dla typu "{3}".
cvc-minExclusive-valid =cvc-minExclusive-valid: wartość "{0}” nie jest prawidłowa w odniesieniu do minExclusive "{1}” dla typu "{2}”.
cvc-minInclusive-valid =cvc-minInclusive-valid: wartość "{0}” nie jest prawidłowa w odniesieniu do minInclusive "{1}” dla typu "{2}”.
cvc-minLength-valid =cvc-minLength-valid: Wartość "{0}" o długości = "{1}" nie jest prawidłowa aspektu w odniesieniu do minLength "{2}" dla typu "{3}".
cvc-pattern-valid =cvc-pattern-valid: wartość "{0}” nie jest prawidłowa w odniesieniu do wzorca "{1}” dla typu "{2}”.
cvc-totalDigits-valid =cvc-totalDigits-valid: Wartość "{0}" ma łącznie {1} cyfr, ale liczba wszystkich cyfr została ograniczona do {2}.
cvc-type.1 =cvc-type.1: Nie znaleziono definicji typu "{0}".
cvc-type.2 =cvc-type.2: Definicja typu nie może być abstrakcyjna dla elementu {0}.
cvc-type.3.1.1 =cvc-type.3.1.1: Element "{0}” jest typem prostym, więc nie może mieć atrybutów, z wyjątkiem tych, których nazwa przestrzeni nazw jest identyczna z "http://www.w3.org/2001/XMLSchema -instance” i którego [nazwa lokalna] jest jednym z "typ”, "nil”, "schemaLocation” lub "noNamespaceSchemaLocation”. Znaleziono jednak atrybut "{1}”.
cvc-type.3.1.2 =cvc-type3.1.2: Element "{0}" jest prostym typem, więc nie może zawierać elementu informacyjnego [dzieci].
cvc-type.3.1.3 =cvc-type.3.1.3: Wartość "{1}" elementu "{0}" jest nieprawidłowa.
schema_reference.4 =schema_reference.4: Nie można odczytać dokumentu schematu "{0}”, ponieważ 1) nie można znaleźć dokumentu; 2) dokument nie mógł być odczytany; 3) głównym elementem dokumentu nie jest <xsd:schema>.
src-annotation =src-annotation: elementy <annotation> mogą zawierać tylko elementy <appinfo> i <documentation>, ale znaleziono "{0}".
src-attribute.1 =src-attribute.1: Właściwości "default” i "fixed” nie mogą występować w deklaracji atrybutu "{0}”. Użyj tylko jednego z nich.
src-attribute.2 =src-attribute.2: : Właściwość "default” jest obecna w atrybucie "{0}”, więc wartość "use” musi być "opcjonalna”.
src-attribute.3.1 =src-attribute.3.1: Jeden z "ref” lub "name” musi być obecny w lokalnej deklaracji atrybutu.
src-attribute.3.2 =src-attribute.3.2: Treść musi być zgodna (adnotacja?) dla odwołania atrybutu "{0}".
src-attribute.4 =src-attribute.4: Atrybut "{0}” ma zarówno atrybut "type”, jak i anonimowy element potomny "simpleType”. Tylko jeden z nich jest dozwolony dla atrybutu.
src-attribute_group.2 =src-attribute_group.2: Przecięcie symboli wieloznacznych nie jest możliwe do wyrażenia dla grupy atrybutów "{0}”.
src-attribute_group.3 =src-attribute_group.3: Wykryto cykliczne definicje dla grupy atrybutów "{0}”. Rekurencyjne śledzenie odwołań do grup atrybutów w końcu prowadzi z powrotem do siebie.
src-ct.1 =src-ct.1: Błąd reprezentacji definicji typu złożonego dla typu "{0}”. Gdy używany jest <complexContent>, typem podstawowym musi być complexType. "{1}" to simpleType.
src-ct.2.1 =src-ct.2.1: Błąd reprezentacji definicji typu złożonego dla typu "{0}”. W przypadku użycia <simpleContent> typ podstawowy musi być typem complexType, którego typ zawartości jest prosty lub, tylko jeśli określono ograniczenie, typem złożonym z zawartością mieszaną i pustą cząstką lub, tylko jeśli określono rozszerzenie, typem prostym. "{1}" nie spełnia żadnego z tych warunków.
src-ct.2.2 =src-ct.2.2: Błąd reprezentacji definicji typu złożonego dla typu "{0}”. Gdy complexType z simpleContent ogranicza typ complexType z zawartością mieszaną i cząsteczką, którą można opróżnić, wówczas musi istnieć element <simpleType> wśród elementów potomnych <restriction>.
src-ct.4 =src-ct.4: Błąd reprezentacji definicji typu złożonego dla typu "{0}”. Przecięcie symboli wieloznacznych nie jest wyrażalne.
src-ct.5 =src-ct.5: Błąd reprezentacji definicji typu złożonego dla typu "{0}”. Połączenie symboli wieloznacznych nie jest wyrażalne.
src-element.1 =src-element.1: Właściwości "default” i "fixed” nie mogą występować w deklaracji elementu "{0}”. Użyj tylko jednego z nich.
src-element.2.1 =src-element.2.1: : Jeden z "ref” lub "name” musi być obecny w deklaracji elementu lokalnego.
src-element.2.2 =src-element.2.2: Ponieważ "{0}" zawiera atrybut "ref", jego zawartość musi być zgodna (adnotacja?). Jednak znaleziono "{1}”.
src-element.3 =src-element.3: Element "{0}" ma zarówno atrybut "type", jak i potomek "typ anonimowy". Tylko jeden z nich jest dozwolony dla elementu.
src-import.1.1 =src-import.1.1: Atrybut przestrzeni nazw "{0}" elementu informacyjnego elementu <import> nie może być taki sam jak targetNamespace schematu, w którym istnieje.
src-import.1.2 =src-import.1.2: Jeśli atrybut namespace nie występuje w elemencie informacyjnym elementu <import>, to otaczający schemat musi mieć targetNamespace.
src-import.2 =src-import.2: Główny element dokumentu "{0}” musi mieć nazwę przestrzeni nazw "http://www.w3.org/2001/XMLSchema” i lokalną nazwę "schema” .
src-import.3.1 =src-import.3.1: Atrybut namespace "{0}" elementu informacyjnego elementu <import> musi być identyczny z atrybutem targetNamespace "{1}" importowanego dokumentu.
src-import.3.2 =src-import.3.2: Znaleziono przedmiot informacyjny elementu <import>, który nie miał atrybutu przestrzeni nazw, więc importowany dokument nie może mieć atrybutu targetNamespace. Jednak w importowanym dokumencie znaleziono przestrzeń targetNamespace "{1}".
src-include.1 =src-include.1: Główny element dokumentu "{0}” musi mieć nazwę przestrzeni nazw "http://www.w3.org/2001/XMLSchema” i lokalną nazwę "schema” .
src-include.2.1 =src-include.2.1: Przestrzeń targetNamespace przywoływanego schematu, obecnie "{1}", musi być identyczna z tą ze schematu dołączającego, obecnie "{0}".
src-redefine.2 =src-redefine.2: Główny element dokumentu "{0}” musi mieć nazwę przestrzeni nazw "http://www.w3.org/2001/XMLSchema” i lokalną nazwę "schema” .
src-redefine.3.1 =src-redefine.3.1: Przestrzeń targetNamespace przywoływanego schematu, obecnie "{1}", musi być identyczna z przestrzenią redefiniującego schematu, obecnie "{0}".
src-redefine.5.a.a =src-redefine.5.a.a: Nie znaleziono elementów podrzędnych <simpleType> bez adnotacji. Elementy potomne <simpleType> elementów <redefine> muszą mieć potomków <restriction> z atrybutami "base”, które odnoszą się do nich samych.
src-redefine.5.a.b =src-redefine.5.a.b: "{0}” nie jest prawidłowym elementem potomnym. Elementy potomne <simpleType> elementów <redefine> muszą mieć potomków <restriction> z atrybutami "base”, które odnoszą się do nich samych.
src-redefine.5.a.c =src-redefine.5.a.c: "{0}" nie ma atrybutu "podstawa", który odnosi się do przedefiniowanego elementu "{1}". Elementy potomne <simpleType> elementów <redefine> muszą mieć potomków <restriction> z atrybutami "base”, które odnoszą się do nich samych.
src-redefine.5.b.a =src-redefine.5.b.a: Nie znaleziono dzieci nie będących adnotacjami <complexType>. Elementy potomne <complexType> elementów <redefine> muszą mieć potomków <extension> lub <restriction> z atrybutami "base", które odnoszą się do siebie.
src-redefine.5.b.b =src-redefine.5.b.b: Nie znaleziono wnuków bez adnotacji <complexType>. Elementy potomne <complexType> elementów <redefine> muszą mieć potomków <extension> lub <restriction> z atrybutami "base", które odnoszą się do siebie.
src-redefine.5.b.c =src-redefine.5.b.c: "{0}" nie jest prawidłowym elementem wnuka. Elementy potomne <complexType> elementów <redefine> muszą mieć potomków <extension> lub <restriction> z atrybutami "base”, które odnoszą się do siebie.
src-redefine.5.b.d =src-redefine.5.b.d: "{0}" nie ma atrybutu "base", który odnosi się do przedefiniowanego elementu "{1}". Elementy potomne <complexType> elementów <redefine> muszą mieć potomków <extension> lub <restriction> z atrybutami "base”, które odnoszą się do siebie.
src-redefine.6.1.1 =src-redefine.6.1.1: Jeśli grupa potomna elementu <redefine> zawiera grupę odwołującą się do siebie, musi mieć dokładnie 1; ten ma "{0}".
src-redefine.6.1.2 =src-redefine.6.1.2: Grupa "{0}", która zawiera odniesienie do przedefiniowanej grupy, musi mieć "minOccurs" = "maxOccurs" = 1.
src-redefine.6.2.1 =src-redefine.6.2.1: Żadna grupa w przedefiniowanym schemacie nie ma nazwy pasującej do "{0}".
src-redefine.6.2.2 =src-redefine.6.2.2: Grupa "{0}" nie ogranicza prawidłowo grupy, którą redefiniuje; naruszone ograniczenie: "{1}".
src-redefine.7.1 =src-redefine.7.1: Jeśli element podrzędny attributeGroup elementu <redefine> zawiera odwołujący się do siebie attributeGroup, musi mieć dokładnie 1; ten ma {0}.
src-redefine.7.2.1 =src-redefine.7.2.1: Żadna grupa atrybutów w przedefiniowanym schemacie nie ma nazwy zgodnej z "{0}".
src-redefine.7.2.2 =src-redefine.7.2.2: AttributeGroup "{0}" nie ogranicza poprawnie atrybutu attributeGroup, który redefiniuje; naruszone ograniczenie: "{1}".
src-resolve =src-resolve: Nie można przetłumaczyć nazwy "{0}" na komponent "{1}".
src-resolve.4.1 =src-resolve.4.1: Błąd podczas rozpoznawania komponentu "{2}”. Wykryto, że "{2}” nie ma przestrzeni nazw, ale komponenty bez docelowej przestrzeni nazw nie są dostępne z dokumentu schematu "{0}”. Jeśli "{2}" ma mieć przestrzeń nazw, być może trzeba podać przedrostek. Jeśli zakłada się, że "{2}” nie ma przestrzeni nazw, wówczas "import” bez atrybutu "namespace” powinien zostać dodany do "{0}”.
src-resolve.4.2 =src-resolve.4.2: Błąd podczas rozpoznawania komponentu "{2}”. Wykryto, że "{2}” znajduje się w przestrzeni nazw "{1}”, ale do komponentów z tej przestrzeni nazw nie można się odwoływać z dokumentu schematu "{0}”. Jeśli jest to nieprawidłowa przestrzeń nazw, być może należy zmienić przedrostek "{2}”. Jeśli jest to prawidłowa przestrzeń nazw, odpowiedni znacznik "import” powinien zostać dodany do "{0}”.
src-simple-type.2.a =src-simple-type.2.a: Znaleziono element <ograniczenie>, który ma zarówno element podstawowy [atrybut], jak i element <simpleType> wśród swoich [potomków]. Dozwolony jest tylko jeden.
src-simple-type.2.b =src-simple-type.2.b: Znaleziono element <ograniczenie>, który nie ma ani podstawowego [atrybutu], ani elementu <simpleType> wśród swoich [potomków]. Jeden jest wymagany.
src-simple-type.3.a =src-simple-type.3.a: Znaleziono element <list>, który ma zarówno element itemType [atrybut], jak i element <simpleType> wśród swoich [dzieci]. Dozwolony jest tylko jeden.
src-simple-type.3.b =src-simple-type.3.b: Znaleziono element <list>, który nie ma ani elementu itemType [atrybut], ani elementu <simpleType> wśród swoich [dzieci]. Jeden jest wymagany.
src-single-facet-value =src-single-facet-value: aspekt "{0}” jest zdefiniowany więcej niż raz.
src-union-memberTypes-or-simpleTypes =src-union-memberTypes-or-simpleTypes: Element <union> musi mieć niepusty element memberTypes [atrybut] lub co najmniej jeden element <simpleType> wśród swoich [dzieci].
ag-props-correct.2 =ag-props-correct.2: Błąd dla grupy atrybutów "{0}”. Określono zduplikowane zastosowania atrybutów o tej samej nazwie i docelowej przestrzeni nazw. Nazwa użycia zduplikowanego atrybutu to "{1}".
ag-props-correct.3 =ag-props-correct.3: Błąd dla grupy atrybutów "{0}”. Dwie deklaracje atrybutów, "{1}" i "{2}" mają typy wywodzące się z ID.
a-props-correct.2 =a-props-correct.2: Nieprawidłowa wartość ograniczenia wartości "{1}” w atrybucie "{0}”.
a-props-correct.3 =a-props-correct.3: Atrybut "{0}” nie może używać "stały” lub "domyślny”, ponieważ "{"definicja typu”}” atrybutu jest identyfikatorem lub jest pochodną z ID.
au-props-correct.2 =au-props-correct.2: W deklaracji atrybutu "{0}" określono stałą wartość "{1}". Zatem jeśli użycie atrybutu odnoszące się do "{0}” ma również "{”ograniczenie wartości”}”, musi ono zostać ustalone, a jego wartość musi wynosić "{1}”.
cos-all-limited.1.2 =cos-all-limited.1.2: Grupa modeli "all" musi pojawić się w cząstce z "{"min występuje"}" = "{"max występuje"}" = 1, a ta cząstka musi być częścią pary, która stanowi "{"content type"}" definicji typu złożonego.
cos-all-limited.2 =cos-all-limited.2: "{"maksimum występuje"}" elementu w grupie modeli "all" musi wynosić 0 lub 1. Wartość "{0}" dla elementu "{1 }" jest nieważny.
cos-applicable-facets =cos-applicable-facets: aspekt "{0}” nie jest dozwolony przez typ {1}.
cos-ct-extends.1.1 =cos-ct-extends.1.1: Typ "{0}” wywodzi się z rozszerzenia z typu "{1}”. Jednak atrybut "final” w "{1}” zabrania wyprowadzania przez rozszerzenie.
cos-ct-extends.1.4.3.2.2.1.a =cos-ct-extends.1.4.3.2.2.1.a: Typ zawartości typu pochodnego i jego podstawy muszą być mieszane lub oba muszą być tylko elementem. Typ "{0}” jest tylko elementem, ale jego typ bazowy nie.
cos-ct-extends.1.4.3.2.2.1.b =cos-ct-extends.1.4.3.2.2.1.b: Typ zawartości typu pochodnego i jego podstawy muszą być mieszane lub oba muszą być tylko elementem. Typ "{0}” jest mieszany, ale jego typ podstawowy nie.
cos-element-consistent =cos-element-consistent: Błąd dla typu "{0}”. W grupie modeli pojawia się wiele elementów o nazwie "{1}”, o różnych typach.
cos-list-of-atomic =cos-list-of-atomic: W definicji typu listy "{0}” typ "{1}” jest nieprawidłowym typem elementu listy, ponieważ nie jest niepodzielny (”{1}” jest albo typ listy, albo typ unii, który zawiera listę).
cos-nonambig =cos-nonambig: {0} i {1} (lub elementy z ich grupy podstawień) naruszają "Unikalne przypisanie cząstek". Podczas walidacji względem tego schematu powstałaby niejednoznaczność dla tych dwóch cząstek.
cos-particle-restrict.a =cos-particle-restrict.a: Pochodna cząstka jest pusta, a podstawa nie jest możliwa do opróżnienia.
cos-particle-restrict.b =cos-particle-restrict.b: Cząstka podstawowa jest pusta, ale cząstka pochodna nie.
cos-particle-restrict.2 =cos-particle-restrict.2: Zabronione ograniczenie cząstek: "{0}".
cos-st-restricts.1.1 =cos-st-restricts.1.1: Typ "{1}” jest atomowy, więc jego "{”definicja typu podstawowego”}”, "{0}” musi być atomową definicją typu prostego lub skompilowaną -w pierwotnym typie danych.
cos-st-restricts.2.1 =cos-st-restricts.2.1: W definicji typu listy "{0}” typ "{1}” jest nieprawidłowym typem elementu, ponieważ jest to typ listy lub typ unii, który zawiera lista.
cos-st-restricts.2.3.1.1 =cos-st-restricts.2.3.1.1: Komponent "{"final"}" "{"definicja typu elementu"}", "{0}", zawiera "listę". Oznacza to, że "{0}” nie może być używany jako typ elementu dla typu listy "{1}”.
cos-st-restricts.3.3.1.1 =cos-st-restricts.3.3.1.1: Komponent "{"final"}" w "{"definicje typu elementu członkowskiego"}", "{0}", zawiera "union". Oznacza to, że "{0}” nie może być używany jako typ członka dla typu unii "{1}”.
cos-valid-default.2.1 =cos-valid-default.2.1: Element "{0}" ma ograniczenie wartości i musi mieć mieszany lub prosty model zawartości.
cos-valid-default.2.2.2 =cos-valid-default2.2.2: Ponieważ element "{0}" ma "{"ograniczenie wartości"}", a jego definicja typu miesza "{"typ zawartości"}", wtedy cząstka "{"Typ treści"}" musi być możliwy do opróżnienia.
c-props-correct.2 =c-props-correct.2: Liczność pól dla odnośnika "{0}” i klucza "{1}” muszą się zgadzać.
ct-props-correct.3 =ct-props-correct.3: Wykryto cykliczne definicje dla typu złożonego "{0}”. Oznacza to, że "{0}” znajduje się we własnej hierarchii typów, co jest błędem.
ct-props-correct.4 =ct-props-correct.4: Błąd dla typu "{0}”. Określono zduplikowane zastosowania atrybutów o tej samej nazwie i docelowej przestrzeni nazw. Nazwa użycia zduplikowanego atrybutu to "{1}".
ct-props-correct.5 =ct-props-correct.5: Błąd dla typu "{0}”. Dwie deklaracje atrybutów, "{1}" i "{2}" mają typy wywodzące się z ID.
derivation-ok-restriction.1 =derivation-ok-restriction.1: Typ "{0}” został wyprowadzony przez ograniczenie z typu "{1}”. Jednak "{1}" ma właściwość "{"final"}", która zabrania wyprowadzania przez ograniczenie.
derivation-ok-restriction.2.1.1 =derivation-ok-restriction.2.1.1: Błąd dla typu "{0}”. Użycie atrybutu "{1}" w tym typie ma wartość "use" wynoszącą "{2}", co jest niezgodne z wartością "required" w dopasowanym atrybucie używanym w bazie rodzaj.
derivation-ok-restriction.2.1.2 =derivation-ok-restriction2.1.2: Błąd dla typu "{0}”. Użycie atrybutu "{1}” w tym typie ma typ "{2}”, który nie jest prawidłowo wyprowadzony z "{3}”, typu zgodnego atrybutu używanego w typie podstawowym.
derivation-ok-restriction.2.1.3.a =derivation-ok-restriction.2.1.3.a: Błąd dla typu "{0}”. Użycie atrybutu "{1}” w tym typie ma ograniczenie wartości efektywnej, które nie jest ustalone, a ograniczenie wartości efektywnej użycia pasującego atrybutu w typie podstawowym jest stałe.
derivation-ok-restriction.2.1.3.b =derivation-ok-restriction.2.1.3.b: Błąd dla typu "{0}”. Użycie atrybutu "{1}” w tym typie ma ograniczenie wartości efektywnej ustalone na wartość "{2}”, co nie jest zgodne z wartością "{3}” dla ustalonej wartości efektywnej ograniczenie wartości pasującego atrybutu użycia w typie podstawowym.
derivation-ok-restriction.2.2.a =derivation-ok-restriction.2.2.a: Błąd dla typu "{0}”. Użycie atrybutu "{1}” w tym typie nie ma pasującego atrybutu użycia w podstawowym, a typ podstawowy nie ma atrybutu wieloznacznego.
derivation-ok-restriction.2.2.b =derivation-ok-restriction.2.2.b: Błąd dla typu "{0}”. Użycie atrybutu "{1}” w tym typie nie ma pasującego atrybutu użycia w bazie, a symbol wieloznaczny w typie podstawowym nie zezwala na użycie przestrzeni nazw "{2}” tego atrybutu.
derivation-ok-restriction.3 =derivation-ok-restriction.3: Błąd dla typu "{0}”. Użycie atrybutu "{1}” w typie podstawowym ma wartość WYMAGANE jako true, ale nie ma pasującego użycia atrybutu w typie pochodnym.
derivation-ok-restriction.4.1 =derivation-ok-restriction.4.1: Błąd dla typu "{0}”. Wyprowadzenie ma atrybut wieloznaczny, ale baza go nie ma.
derivation-ok-restriction.4.2 =derivation-ok-restriction.4.2: Błąd dla typu "{0}”. Symbol wieloznaczny w wyprowadzeniu nie jest prawidłowym podzbiorem symboli wieloznacznych tego w bazie.
derivation-ok-restriction.4.3 =derivation-ok-restriction.4.3: Błąd dla typu "{0}”. Zawartość procesu symbolu wieloznacznego w wyprowadzeniu ({1}) jest słabsza niż w bazie ({2}).
derivation-ok-restriction.5.2.2.1 =derivation-ok-restriction.5.2.2.1: Błąd dla typu "{0}”. Prosty typ treści tego typu "{1}” nie jest prawidłowym ograniczeniem prostego typu treści bazy "{2}”.
derivation-ok-restriction.5.3.2 =derivation-ok-restriction.5.3.2: Błąd dla typu "{0}”. Typ zawartości tego typu jest pusty, ale typ zawartości bazy "{1}” nie jest pusty ani możliwy do opróżnienia.
derivation-ok-restriction.5.4.1.2 =derivation-ok-restriction.5.4.1.2: Błąd dla typu "{0}”. Typ zawartości tego typu jest mieszany, ale typ zawartości bazy "{1}” już nie.
derivation-ok-restriction.5.4.2 =derivation-ok-restriction.5.4.2: Błąd dla typu "{0}”. Cząstka typu nie jest ważnym ograniczeniem cząstki podstawy.
enumeration-required-notation =enumeration-required-notation: typ NOTATION, "{0}" używany przez {2} "{1}", musi mieć wartość aspektu wyliczenia, która określa elementy notacji używane przez ten typ.
enumeration-valid-restriction =enumeration-valid-restriction: Wartość wyliczenia "{0}" nie znajduje się w przestrzeni wartości typu podstawowego {1}.
e-props-correct.2 =e-props-correct.2: Nieprawidłowa wartość ograniczenia wartości "{1}" w elemencie "{0}".
e-props-correct.4 =e-props-correct.4: "{"definicja typu"}" elementu "{0}" nie jest poprawnie wyprowadzona z "{"definicja typu"}" substitutionHead "{1}" lub właściwość "{"wykluczenia grup zastępczych"}" "{1}" nie zezwala na to wyprowadzenie.
e-props-correct.5 =e-props-correct.5: "{"ograniczenie wartości"}" nie może znajdować się na elemencie "{0}", ponieważ element "{"definicja typu"}" lub "{"typ definicja"}""s "{"content type"}" to ID lub pochodzi od ID.
e-props-correct.6 =e-props-correct.6: Wykryto cykliczną grupę podstawień dla elementu "{0}”.
fractionDigits-valid-restriction =fractionDigits-valid-restriction: w definicji {2} wartość "{0}” dla aspektu "fractionDigits” jest nieprawidłowa, ponieważ musi być <= wartością "fractionDigits”, która była ustaw na "{1}" w jednym z typów przodków.
fractionDigits-totalDigits =fractionDigits-totalDigits: w definicji {2} wartość "{0}” dla aspektu "fractionDigits” jest nieprawidłowa, ponieważ wartość musi wynosić <= wartość "totalDigits”, czyli " "{1}”.
length-minLength-maxLength.1.1 =length-minLength-maxLength.1.1: W przypadku typu {0} błędem jest to, że wartość długości "{1}” jest mniejsza niż wartość minLength "{2}”.
length-minLength-maxLength.1.2.a =length-minLength-maxLength.1.2.a: W przypadku typu {0} błędem jest to, że podstawa nie ma aspektu minLength, jeśli bieżące ograniczenie ma aspekt minLength, a bieżące ograniczenie lub podstawa ma aspekt długości.
length-minLength-maxLength.1.2.b =length-minLength-maxLength.1.2.b: W przypadku typu {0} błąd oznacza, że ​​bieżąca minLength "{1}" nie jest równa podstawowej minLength "{2}".
length-minLength-maxLength.2.1 =length-minLength-maxLength.2.1: W przypadku typu {0} błędem jest to, że wartość długości "{1}" jest większa niż wartość maxLength "{2}".
length-minLength-maxLength.2.2.a =length-minLength-maxLength.2.2.a: W przypadku typu {0} błędem jest to, że podstawa nie ma aspektu maxLength, jeśli bieżące ograniczenie ma aspekt maxLength, a bieżące ograniczenie lub podstawa ma aspekt długości.
length-minLength-maxLength.2.2.b =length-minLength-maxLength.2.2.b: W przypadku typu {0} błędem jest to, że bieżąca maxLength "{1}" nie jest równa bazowej maxLength "{2}".
length-valid-restriction =długość-prawidłowe-ograniczenie: Błąd dla typu "{2}”. Wartość length = "{0}" musi być = wartość typu podstawowego "{1}".
maxExclusive-valid-restriction.1 =maxExclusive-valid-restriction.1: Błąd dla typu "{2}”. Wartość maxExclusive ="{0}" musi być <= maxExclusive typu podstawowego "{1}".
maxExclusive-valid-restriction.2 =maxExclusive-valid-restriction.2: Błąd dla typu "{2}”. Wartość maxExclusive ="{0}" musi być <= maxInclusive typu podstawowego "{1}".
maxExclusive-valid-restriction.3 =maxExclusive-valid-restriction.3: Błąd dla typu "{2}”. Wartość maxExclusive ="{0}" musi być > minInclusive typu podstawowego "{1}".
maxExclusive-valid-restriction.4 =maxExclusive-valid-restriction.4: Błąd dla typu "{2}”. Wartość maxExclusive ="{0}" musi być > minExclusive typu podstawowego "{1}".
maxInclusive-maxExclusive =maxInclusive-maxExclusive: błędem jest określenie zarówno maxInclusive, jak i maxExclusive dla tego samego typu danych. W {2} maxInclusive = "{0}" i maxExclusive = "{1}".
maxInclusive-valid-restriction.1 =maxInclusive-valid-restriction.1: Błąd dla typu "{2}”. Wartość maxInclusive ="{0}" musi być <= maxInclusive typu podstawowego "{1}".
maxInclusive-valid-restriction.2 =maxInclusive-valid-restriction.2: Błąd dla typu "{2}”. Wartość maxInclusive ="{0}" musi być < maxExclusive typu podstawowego "{1}".
maxInclusive-valid-restriction.3 =maxInclusive-valid-restriction.3: Błąd dla typu "{2}”. Wartość maxInclusive ="{0}" musi być >= minInclusive typu podstawowego "{1}".
maxInclusive-valid-restriction.4 =maxInclusive-valid-restriction.4: Błąd dla typu "{2}”. Wartość maxInclusive ="{0}" musi być > minExclusive typu podstawowego "{1}".
maxLength-valid-restriction =maxLength-valid-restriction: W definicji {2}, wartość maxLength = "{0}" musi być <= tego typu podstawowego "{1}".
mg-props-correct.2 =mg-props-correct.2: Wykryto cykliczne definicje dla grupy "{0}”. Rekurencyjne podążanie za wartościami "{"term"}" cząstek prowadzi do cząstki, której "{"term"}" jest samą grupą.
minExclusive-less-than-equal-to-maxExclusive =minExclusive-less-than-equal-to-maxExclusive: w definicji {2}, minExclusive value = "{0}" musi być <= maxExclusive value = "{1}".
minExclusive-less-than-maxInclusive =minExclusive-less-than-maxInclusive: w definicji {2} wartość minExclusive = "{0}" musi być < maxInclusive value = "{1}".
minExclusive-valid-restriction.1 =minExclusive-valid-restriction.1: Błąd dla typu "{2}”. Wartość minExclusive ="{0}" musi być >= minExclusive typu podstawowego "{1}".
minExclusive-valid-restriction.2 =minExclusive-valid-restriction.2: Błąd dla typu "{2}”. Wartość minExclusive ="{0}" musi wynosić <= maxInclusive typu podstawowego "{1}".
minExclusive-valid-restriction.3 =minExclusive-valid-restriction.3: Błąd dla typu "{2}”. Wartość minExclusive ="{0}" musi być >= minInclusive typu podstawowego "{1}".
minExclusive-valid-restriction.4 =minExclusive-valid-restriction.4: Błąd dla typu "{2}”. Wartość minExclusive ="{0}" musi być < maxExclusive typu podstawowego "{1}".
minInclusive-less-than-equal-to-maxInclusive =minInclusive-less-than-equal-to-maxInclusive: w definicji {2}, wartość minInclusive = "{0}" musi być <= wartość maxInclusive = "{1}".
minInclusive-less-than-maxExclusive =minInclusive-less-than-maxExclusive: w definicji {2} wartość minInclusive = "{0}" musi być < wartość maxExclusive = "{1}".
minInclusive-minExclusive =minInclusive-minExclusive: Jest to błąd dla minInclusive i minExclusive, które zostały określone dla tego samego typu danych. W {2} minInclusive = "{0}" i minExclusive = "{1}".
minInclusive-valid-restriction.1 =minInclusive-valid-restriction.1: Błąd dla typu "{2}”. Wartość minInclusive ="{0}" musi być >= minInclusive typu podstawowego "{1}".
minInclusive-valid-restriction.2 =minInclusive-valid-restriction.2: Błąd dla typu "{2}”. Wartość minInclusive ="{0}" musi być <= maxInclusive typu podstawowego "{1}".
minInclusive-valid-restriction.3 =minInclusive-valid-restriction.3: Błąd dla typu "{2}”. Wartość minInclusive ="{0}" musi być > minExclusive typu podstawowego "{1}".
minInclusive-valid-restriction.4 =minInclusive-valid-restriction.4: Błąd dla typu "{2}”. Wartość minInclusive ="{0}" musi być < maxExclusive typu podstawowego "{1}".
minLength-less-than-equal-to-maxLength =minLength-mniej-niż-równa-do-maxLength: W definicji {2}, wartość minLength = "{0}" musi być < wartość maxLength = "{1}".
minLength-valid-restriction =minLength-valid-restriction: w definicji {2} minLength = "{0}" musi być >= niż typ podstawowy, "{1}".
no-xmlns =no-xmlns: {name} deklaracji atrybutu nie może być zgodne z "xmlns”.
no-xsi =no-xsi: "{"docelowa przestrzeń nazw"}" deklaracji atrybutu nie może być zgodna z "{0}".
p-props-correct.2.1 =p-props-correct.2.1: W deklaracji "{0}” wartość "minOccurs” wynosi "{1}”, ale nie może być większa niż wartość "maxOccurs” ", czyli "{2}".
rcase-MapAndSum.1 =rcase-MapAndSum.1: Nie ma pełnego funkcjonalnego mapowania między cząstkami.
rcase-MapAndSum.2 =rcase-MapAndSum.2: Zakres występowania grupy ({0},{1}) nie jest prawidłowym ograniczeniem zakresu występowania grupy podstawowej ({2},{3}).
rcase-NameAndTypeOK.1 =rcase-NameAndTypeOK.1: Elementy mają nazwy i docelowe przestrzenie nazw, które nie są takie same: Element "{0}" w przestrzeni nazw "{1}" i element "{2}" w przestrzeni nazw "{3 }".
rcase-NameAndTypeOK.2 =rcase-NameAndTypeOK.2: Błąd dla cząstki, której "{"term"}" jest deklaracją elementu "{0}". Deklaracja elementu "{"nillable"}" jest prawdziwa, ale odpowiadająca jej cząstka w typie bazowym ma deklarację elementu, której "{"nillable"}" jest fałszywe.
rcase-NameAndTypeOK.3 =rcase-NameAndTypeOK.3: Błąd dla cząstki, której "{"term"}" jest deklaracją elementu "{0}". Jego zakres występowania ({1},{2}) nie jest prawidłowym ograniczeniem zakresu ({3},{4}) odpowiedniej cząstki w typie podstawowym.
rcase-NameAndTypeOK.4.a =rcase-NameAndTypeOK.4.a: Element "{0}" nie jest ustalony, ale odpowiadający mu element w typie podstawowym jest ustalony z wartością "{1}".
rcase-NameAndTypeOK.4.b =rcase-NameAndTypeOK.4.b: Element "{0}" jest ustalony wartością "{1}", ale odpowiadający mu element w typie podstawowym jest ustalony za pomocą wartości "{2}".
rcase-NameAndTypeOK.5 =rcase-NameAndTypeOK.5: Ograniczenia tożsamości dla elementu "{0}" nie są podzbiorem tych w bazie.
rcase-NameAndTypeOK.6 =rcase-NameAndTypeOK.6: Niedozwolone podstawienia elementu "{0}” nie są nadzbiorem tych w bazie.
rcase-NameAndTypeOK.7 =rcase-NameAndTypeOK.7: Typ elementu "{0}", "{1}", nie pochodzi od typu elementu podstawowego "{2}".
rcase-NSCompat.1 =rcase-NSCompat.1: Element "{0}" ma przestrzeń nazw "{1}", która nie jest dozwolona przez symbol wieloznaczny w bazie.
rcase-NSCompat.2 =rcase-NSCompat.2: Błąd dla cząstki, której "{"term"}" jest deklaracją elementu "{0}". Jego zakres występowania ({1},{2}) nie jest prawidłowym ograniczeniem zakresu ({3},{4}) odpowiedniej cząstki w typie podstawowym.
rcase-NSRecurseCheckCardinality.1 =rcase-NSRecurseCheckCardinality.1: Nie ma pełnego mapowania funkcjonalnego między cząstkami.
rcase-NSRecurseCheckCardinality.2 =rcase-NSRecurseCheckCardinality.2: Zakres występowania grupy ({0}, {1}) nie jest prawidłowym ograniczeniem zakresu podstawowego symbolu wieloznacznego ({2}, {3}).
rcase-NSSubset.1 =rcase-NSSubset.1: Symbol wieloznaczny nie jest podzbiorem odpowiedniego symbolu wieloznacznego w bazie.
rcase-NSSubset.2 =rcase-NSSubset.2: Zakres występowania symbolu wieloznacznego ({0},{1}) nie jest prawidłowym ograniczeniem tego w bazie ({2},{3}).
rcase-NSSubset.3 =rcase-NSSubset.3: Zawartość procesu Wildcard, "{0}", jest słabsza niż ta w bazie, "{1}".
rcase-Recurse.1 =rcase-Recurse.1: Zakres występowania grupy ({0},{1}) nie jest prawidłowym ograniczeniem zakresu występowania grupy podstawowej ({2},{3}).
rcase-Recurse.2 =rcase-Recurse.2: Nie ma pełnego funkcjonalnego mapowania między cząstkami.
rcase-RecurseLax.1 =rcase-RecurseLax.1: Zakres występowania grupy ({0},{1}) nie jest prawidłowym ograniczeniem zakresu występowania grupy podstawowej ({2},{3}).
rcase-RecurseLax.2 =rcase-RecurseLax.2: Nie ma pełnego funkcjonalnego mapowania między cząstkami.
rcase-RecurseUnordered.1 =rcase-RecurseUnordered.1: Zakres występowania grupy ({0},{1}) nie jest prawidłowym ograniczeniem zakresu występowania grupy podstawowej ({2},{3}).
rcase-RecurseUnordered.2 =rcase-RecurseUnordered.2: Nie ma pełnego funkcjonalnego mapowania między cząstkami.
sch-props-correct.2 =sch-props-correct.2: schemat nie może zawierać dwóch globalnych komponentów o tej samej nazwie; ten schemat zawiera dwa wystąpienia "{0}”.
st-props-correct.2 =st-props-correct.2: Wykryto cykliczne definicje dla prostego typu "{0}”. Oznacza to, że "{0}” znajduje się we własnej hierarchii typów, co jest błędem.
st-props-correct.3 =st-props-correct.3: Błąd dla typu "{0}”. Wartość "{"final"}" "{"definicji typu bazowego"}", "{1}", zabrania wyprowadzania przez ograniczenie.
totalDigits-valid-restriction =totalDigits-valid-restriction: w definicji {2} wartość "{0}" dla aspektu "totalDigits" jest nieprawidłowa, ponieważ musi być <= wartością "totalDigits", która była ustaw na "{1}" w jednym z typów przodków.
whiteSpace-valid-restriction.1 =whiteSpace-valid-restriction.1: W definicji {0} wartość "{1}” dla aspektu "whitespace” jest nieprawidłowa, ponieważ wartość "whitespace” została ustawiona na " "zapaść” w jednym z typów przodków.
whiteSpace-valid-restriction.2 =whiteSpace-valid-restriction.2: W definicji {0} wartość "zachowaj” dla aspektu "whitespace” jest nieprawidłowa, ponieważ wartość "whitespace” została ustawiona na "zamień” " w jednym z typów przodków.
s4s-att-invalid-value =s4s-att-invalid-value: Nieprawidłowa wartość atrybutu dla "{1}” w elemencie "{0}”. Zarejestrowany powód: {2}
s4s-att-must-appear =s4s-att-must-appear: Atrybut "{1}” musi pojawić się w elemencie "{0}”.
s4s-att-not-allowed =s4s-att-not-allowed: Atrybut "{1}” nie może pojawić się w elemencie "{0}”.
s4s-elt-invalid =s4s-elt-invalid: Element "{0}" nie jest prawidłowym elementem w dokumencie schematu.
s4s-elt-must-match.1 =s4s-elt-must-match.1: Zawartość "{0}” musi być zgodna z {1}. Wykryto problem rozpoczynający się od: {2}.
s4s-elt-must-match.2 =s4s-elt-must-match.2: Zawartość "{0}” musi być zgodna z {1}. Znaleziono za mało elementów.
s4s-elt-invalid-content.1 =s4s-elt-invalid-content.1: Zawartość "{0}” jest nieprawidłowa. Element "{1}” jest nieprawidłowy, niewłaściwie umieszczony lub występuje zbyt często.
s4s-elt-invalid-content.2 =s4s-elt-invalid-content.2: Zawartość "{0}” jest nieprawidłowa. Element "{1}” nie może być pusty.
s4s-elt-invalid-content.3 =s4s-elt-invalid-content.3: Elementy typu "{0}” nie mogą pojawić się po deklaracjach jako elementy potomne elementu <schema>.
s4s-elt-schema-ns =s4s-elt-schema-ns: Przestrzeń nazw elementu "{0}” musi pochodzić z przestrzeni nazw schematu "http://www.w3.org/2001/XMLSchema”.
s4s-elt-character =s4s-elt-character: Znaki inne niż białe nie są dozwolone w elementach schematu innych niż "xs:appinfo” i "xs:documentation”. Widziałem "{0}”.
c-fields-xpaths =c-fields-xpaths: Wartość pola = "{0}” jest nieprawidłowa.
c-general-xpath =c-general-xpath: Wyrażenie "{0}” jest nieprawidłowe w odniesieniu do podzbioru XPath obsługiwanego przez schemat XML.
c-general-xpath-ns =c-general-xpath-ns: Prefiks przestrzeni nazw w wyrażeniu XPath "{0}" nie był powiązany z przestrzenią nazw.
c-selector-xpath =c-selector-xpath: Wartość selektora = "{0}” jest nieprawidłowa; xpath selektorów nie mogą zawierać atrybutów.
EmptyTargetNamespace =EmptyTargetNamespace: W dokumencie schematu "{0}” wartość atrybutu "targetNamespace” nie może być pustym ciągiem.
FacetValueFromBase =FacetValueFromBase: W deklaracji typu "{0}” wartość "{1}” aspektu "{2}” musi pochodzić z przestrzeni wartości typu podstawowego "{3}” .
FixedFacetValue =FixedFacetValue: w definicji {3} wartość "{1}" dla aspektu "{0}" jest nieprawidłowa, ponieważ wartość "{0}" została ustawiona na "{ 2}" w jednym z typów przodków i "{"fixed"}" = true.
InvalidRegex =InvalidRegex: Wartość wzorca "{0}” nie jest prawidłowym wyrażeniem regularnym. Zgłoszony błąd to: "{1}".
maxOccurLimit =Obecna konfiguracja parsera nie pozwala na rozszerzenie modelu treści dla typu złożonego, aby zawierał więcej niż {0} węzłów.
PublicSystemOnNotation =PublicSystemOnNotation: co najmniej jeden z "public” i "system” musi pojawić się w elemencie "notation”.
SchemaLocation =SchemaLocation: wartość schemaLocation = "{0}" musi mieć parzystą liczbę identyfikatorów URI.
TargetNamespace.1 =TargetNamespace.1: Oczekiwano przestrzeni nazw "{0}”, ale docelowa przestrzeń nazw dokumentu schematu to "{1}”.
TargetNamespace.2 =TargetNamespace.2: nie oczekuje się żadnej przestrzeni nazw, ale dokument schematu ma docelową przestrzeń nazw "{1}”.
UndeclaredEntity =UndeclaredEntity: Jednostka "{0}" nie jest zadeklarowana.
UndeclaredPrefix =UndeclaredPrefix: Nie można rozpoznać "{0}" jako QName: prefiks "{1}" nie jest zadeklarowany.
FacetsContradict =FacetsContradict: w przypadku definicji simpleType "{2}” wartość wyliczenia "{0}” jest sprzeczna z wartością aspektu "{1}”.
jaxp12-schema-source-type.1 =Właściwość "http://java.sun.com/xml/jaxp/properties/schemaSource” nie może mieć wartości typu "{0}”. Możliwe typy obsługiwanej wartości to String, File, InputStream, InputSource lub tablica tych typów.
jaxp12-schema-source-type.2 =Właściwość "http://java.sun.com/xml/jaxp/properties/schemaSource” nie może mieć wartości tablicy typu "{0}”. Możliwe typy obsługiwanej tablicy to Object, String, File, InputStream i InputSource.
jaxp12-schema-source-ns =W przypadku używania tablicy obiektów jako wartości właściwości "http://java.sun.com/xml/jaxp/properties/schemaSource” niedozwolone jest posiadanie dwóch schematów współużytkujących tę samą docelową przestrzeń nazw.

# Additions for XML Schema 1.1 support

cvc-datatype-valid.1.2.4 = cvc-datatype-valid.1.2.4: Typ NOTATION, "{0}" używany do walidacji "{1}", musi mieć wartość aspektu wyliczenia, która określa elementy notacji używane przez ten typ.
cvc-assertion = cvc-assertion: Ocena asercji ("{1}") dla elementu "{0}" w typie schematu "{2}" nie powiodła się. {3}
cvc-assertion-failure-mesg = cvc-assertion-failure-mesg: {0} {1}
cvc-assertions-valid = cvc-assertions-valid: Wartość "{0}" nie jest poprawna aspektowo w odniesieniu do asercji "{1}". {2}
cvc-assertions-valid-union-elem = cvc-assertions-valid-union-elem: Wartość "{0}" nie jest poprawna pod względem fasetowym w odniesieniu do określonych asercji, w typie "{2}" elementu "{1}".
cvc-assertions-valid-union-attr = cvc-assertions-valid-union-attr: Wartość "{0}" nie jest poprawna pod względem fasetowym w odniesieniu do określonych asercji, w typie "{3}" atrybutu "{2}"/@"{1}".
cvc-xpath.3.13.4.2a = cvc-xpath.3.13.4.2a: XPST0003 — Nie można pomyślnie skompilować wyrażenia XPath asercji ("{0}") w typie schematu "{1}".
cvc-xpath.3.13.4.2b = cvc-xpath.3.13.4.2b: Wyrażenie XPath assert, takie jak ("{0}") zaczynające się od / lub //, jest niedopuszczalne w przypadku typu schematu "{1}" (ponieważ drzewo XPath assert jest zakorzenione w elemencie bez rodzica).
src-attribute.5 = src-attribute.5: Właściwość "fixed" jest obecna w atrybucie "{0}", więc wartość "use" nie może być "prohibited".
src-attribute.6.2 = src-attribute.6.2: Ponieważ atrybut "{0}" zawiera atrybut "targetNamespace", atrybut "form" musi być nieobecny.
src-attribute.6.3.1 = src-attribute.6.3.1: Ponieważ atrybut "{0}" zawiera atrybut "targetNamespace", a <schema> nie ma atrybutu "targetNamespace" lub jego wartość różni się od wartości "targetNamespace" elementu "{0}", ``{0}" musi mieć jako przodka <complexType>.
src-attribute.6.3.2 = src-attribute.6.3.2: Ponieważ atrybut "{0}" zawiera atrybut "targetNamespace", a <schema> nie ma atrybutu "targetNamespace" lub jego wartość różni się od wartości "targetNamespace" elementu "{0}", pomiędzy "{0}" a najbliższym przodkiem <complexType> musi istnieć przodek <restriction>, a wartość atrybutu "base" elementu <restriction> nie pasuje do nazwy "xs:anyType".
src-ct.6 = src-ct.5: Błąd reprezentacji definicji typu złożonego dla typu "{0}". Jeśli <openContent> jest obecny, a rzeczywista wartość jego trybu [attribute] jest różna od "none", to wśród [elementów potomnych] elementu <openContent> musi znajdować się <any>.
src-ct.7 = src-ct.7: Grupa atrybutów "{0}" została zadeklarowana więcej niż raz w definicji typu złożonego "{1}".
src-ct11.3 = src-ct11.3: Błąd reprezentacji definicji typu złożonego dla typu "{0}". Jeśli <openContent> jest obecny i ma tryb = "none", to wśród [elementów potomnych] <openContent> nie może znajdować się element <any>.
src-ct11.4 = src-ct11.4: Błąd reprezentacji definicji typu złożonego dla typu "{0}". Jeśli wybrano alternatywę <complexContent>, a atrybut „mixed” jest obecny zarówno w <complexType>, jak i <complexContent>, to rzeczywiste wartości tych atrybutów muszą być takie same.
src-element.4.2 = src-element.4.2: Ponieważ element "{0}" zawiera atrybut "targetNamespace", atrybut "form" musi być nieobecny.
src-element.4.3.1 = src-element.4.3.1: Ponieważ element "{0}" zawiera atrybut "targetNamespace", a <schema> nie ma atrybutu "targetNamespace" lub jego wartość różni się od wartości "targetNamespace" elementu "{0}", "{0}" musi mieć jako przodka <complexType>.
src-element.4.3.2 = src-element.4.3.2: Ponieważ element "{0}" zawiera atrybut "targetNamespace", a <schema> nie ma atrybutu "targetNamespace" lub jego wartość różni się od wartości "targetNamespace" elementu "{0}", musi istnieć przodek <restriction> między "{0}" a najbliższym przodkiem <complexType>, a wartość atrybutu "base" elementu <restriction> nie pasuje do nazwy "xs:anyType".
src-element.5 = src-element.5: Element "{0}" ma typ alternatywny z brakującym atrybutem "test". Tylko ostatni typ alternatywny w tabeli typów może nie mieć atrybutu "test".
src-identity-constraint.1 = src-identity-constraint.1: Deklaracja ograniczenia tożsamości musi zawierać jeden z atrybutów „ref” lub „name”.
src-identity-constraint.5 = src-identity-constraint.5: Kategoria ograniczenia tożsamości w definicji ograniczenia tożsamości, do której odnosi się rzeczywista wartość atrybutu „ref”, nie pasuje do nazwy elementu informacji o elemencie „{0}”.
src-override.2.1 = src-override.2.1: Przestrzeń nazw docelowych (targetNamespace) nadpisanego schematu, obecnie „{1}”, musi być identyczna z nazwą nadpisanego schematu, obecnie „{0}”.
src-override-collision.1 = src-override-collision.1: Identyfikator schematu "{0}", do którego odwołuje się <{1}>, koliduje z już nadpisanym schematem. Odwołany schemat jest ignorowany.
src-override-collision.2 = src-override-collision.2: Transformacja nadpisywania identyfikatora schematu "{0}" koliduje z istniejącym schematem, który został wcześniej uwzględniony, przedefiniowany lub nadpisany. Przekształcony schemat jest ignorowany, a nadpisanie nie zostanie wykonane.
src-type-alternative.3.12.13.1 = src-type-alternative.3.12.13.1: Alternatywa typu ma zarówno atrybut "type", jak i anonimowy element potomny typu. Tylko jeden z tych atrybutów jest dozwolony dla alternatywy typu.
src-type-alternative.3.12.13.2 = src-type-alternative.3.12.13.2: Brak definicji typu dla alternatywy typu. Atrybut „type”, element potomny „complexType” lub element potomny „simpleType” musi być obecny.
src-wildcard.1 = src-wildcard.1: Właściwości „namespace” i „notNamespace” nie mogą występować jednocześnie w deklaracji symbolu wieloznacznego. Użyj tylko jednej z nich.
src-cip.1 = src-cip.1: Atrybut "{0}" nie należy do przestrzeni nazw wersjonowania schematu (http://www.w3.org/2007/XMLSchema-versioning). Dla przestrzeni nazw wersjonowania schematu dostępne są tylko następujące atrybuty: "minVersion", "maxVersion", "typeAvailable", "typeUnavailable", "facetAvailable" i "facetUnavailable".
src-assert.3.13.1 = src-assert.3.13.1: Obowiązkowy atrybut "test" nie pojawia się w elemencie "{0}" w definicji typu "{1}".
cos-all-limited.1.3 = cos-all-limited.1.3: Gdy cząstka xs:group występuje jako element potomny elementu xs:all, wówczas dla cząstki xs:group musi być spełniony następujący warunek: "{"występuje min"}" = "{"występuje max"}" = 1.
cos-all-limited.2-xs11 = cos-all-limited.2-xs11: Znaleziono nieprawidłową instrukcję schematu "{0}" jako element potomny elementu "xs:group", do którego odwołuje się to odwołanie do grupy. Grupy odwoływane z elementu "xs:all" mogą zawierać tylko elementy "xs:all".
cos-ct-extends.1.4.3.2.2.3 = cos-ct-extends.1.4.3.2.2.3: Otwarta zawartość typu bazowego nie jest nieobecna, a typ zawartości typu pochodnego musi mieć tryb „sufiksu” lub „przeplotu”. Typ „{0}” ma otwartą zawartość z trybem „brak”.
cos-ct-extends.1.4.3.2.2.3.3 = cos-ct-extends.1.4.3.2.2.3.3: Otwarta zawartość typu pochodnego i jego typu bazowego muszą mieć tryb „sufiksu”. Typ „{0}” ma otwartą zawartość z trybem „sufiksu”, ale jego typ bazowy nie.
cos-ct-extends.1.4.3.2.2.3.4 = cos-ct-extends.1.4.3.2.2.3.4: Ograniczenie przestrzeni nazw symbolu wieloznacznego dotyczącego otwartej zawartości typu bazowego musi być podzbiorem ograniczenia przestrzeni nazw symbolu wieloznacznego dotyczącego otwartej zawartości typu pochodnego. Nie dotyczy to typu "{0}".
cos-element-consistent.4.a = cos-element-consistent.4: Symbol wieloznaczny pasuje do elementu globalnego "{0}", którego typ "{1}" nie jest prawidłowo pochodną definicji typu "{2}" elementu lokalnego o tej samej nazwie.
cos-element-consistent.4.b = cos-element-consistent.4: Błąd dla typu "{0}". W grupie modeli występuje wiele elementów o nazwie "{1}" z nieekwiwalentnymi tabelami typów.
cos-content-act-restrict.5.3 = cos-content-act-restrict.5.3: Błąd dla typu "{0}". Atrybut use "{1}" w tym typie ma wartość "inheritable", co jest niezgodne z wartością w typie bazowym.
cos-particle-extends.3.1 = cos-particle-extends.3.1: Gdy zarówno typ pochodny, jak i jego typ bazowy zawierają cząstki z <all> jako "{"term"}", minOccurs cząstki pochodnej musi być równe minOccurs cząstki bazowej.
e-props-correct.7 = e-props-correct.7: Alternatywny typ "{1}" nie jest typu xs:error lub nie jest poprawnie wyprowadzony z definicji typu "{2}" elementu "{0}".
st-props-correct.1 = st-props-correct.1: "itemType" typu xs:list i "memberTypes" typu xs:union nie mogą odwoływać się do typów specjalnych, xs:anyAtomicType ani xs:anySimpleType. Składnik "{1}" typu simpleType "{0}" narusza to ograniczenie.
wc-props-correct.2 = wc-props-correct.2: Gdy symbol wieloznaczny ma wartość {variety} równą "not", {namespaces} musi mieć co najmniej jednego członka.
wc-props-correct.4 = wc-props-correct.4: Przestrzeń nazw "{0}" dla niedozwolonej nazwy "{1}" nie jest dozwolona przez symbol wieloznaczny.
minScale-totalDigits = minScale-totalDigits: W definicji {2} wartość minScale = "{0}" musi być <= wartość maxScale = "{1}".
cvc-maxScale-valid = cvc-maxScale-valid: Dla typu {2} i wartości {0} błędem jest, gdy wartość precyzji "{3}" jest większa niż wartość maxScale "{1}".
cvc-minScale-valid = cvc-minScale-valid: Dla typu {2} i wartości {0} błędem jest, gdy wartość precyzji "{3}" jest mniejsza niż wartość minScale "{1}".
cvc-explicitTimezone-valid = cvc-explicitTimezone-valid: Wartość "{0}" nie jest poprawna pod względem fasety względem explicitTimezone "{1}" dla typu "{2}".
maxScale-valid-restriction = maxScale-valid-restriction: W definicji {2}, maxScale value = "{0}" musi być <= wartością typu bazowego "{1}".
minScale-valid-restriction = minScale-valid-restriction: W definicji {2} wartość minScale = "{0}" musi być większa niż wartość typu bazowego "{1}".
timezone-valid-restriction = timezone-valid-restriction: W definicji {0} wartość "{1}" dla aspektu "explicitTimezone" jest nieprawidłowa, ponieważ wartość "explicitTimezone" została ustawiona na "{2}" w jednym z typów nadrzędnych.
c-cta-xpath = c-cta-xpath: Wyrażenie XPath "{0}" nie mogło zostać pomyślnie skompilowane w trybie "{1}" podczas oceny wezwania do działania (CTA).
c-cta-xpath-b = c-cta-xpath-b: Wyrażenie XPath CTA, takie jak ("{0}") zaczynające się od / lub //, jest niedopuszczalne w trybie "{1}" (ponieważ drzewo XPath CTA jest zakorzenione w elemencie bez rodzica).
c-cta-xpath-serr = c-cta-xpath-serr: Wyrażenie XPath "{0}" nie mogło zostać pomyślnie skompilowane w trybie "{1}" podczas ewaluacji CTA. W wyrażeniu XPath wystąpił błąd statyczny "{2}".
